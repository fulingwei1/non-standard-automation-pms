# -*- coding: utf-8 -*-
"""
æ¯›åˆ©ç‡é¢„æµ‹ API
- åŸºäºå†å²é¡¹ç›®æ•°æ®é¢„æµ‹æ–°é¡¹ç›®/æŠ¥ä»·çš„æ¯›åˆ©ç‡
- æŒ‰è®¾å¤‡ç±»å‹ã€å®¢æˆ·è¡Œä¸šã€åˆåŒé‡‘é¢åŒºé—´åˆ†æ
- æˆæœ¬ç»“æ„å¯¹æ¯”å’Œåå·®åˆ†æ
"""

from typing import Any, List, Optional

from fastapi import APIRouter, Depends, Query
from pydantic import BaseModel
from sqlalchemy import text
from sqlalchemy.orm import Session

from app.api import deps
from app.models.user import User

router = APIRouter()


# ============================================================================
# Schemas
# ============================================================================

class CostBreakdown(BaseModel):
    cost_type: str
    amount: float
    percentage: float


class HistoricalProject(BaseModel):
    project_id: int
    project_name: str
    project_code: str
    product_category: Optional[str] = None
    industry: Optional[str] = None
    contract_amount: float
    actual_cost: float
    gross_margin: float  # (contract - cost) / contract * 100
    cost_breakdown: List[CostBreakdown] = []
    stage: Optional[str] = None


class MarginPrediction(BaseModel):
    predicted_margin: float  # é¢„æµ‹æ¯›åˆ©ç‡ %
    confidence: float  # ç½®ä¿¡åº¦ 0-1
    margin_range: tuple  # (min, max) %
    similar_projects_count: int
    avg_margin: float
    median_margin: float
    risk_level: str  # low/medium/high
    cost_structure: List[CostBreakdown]
    similar_projects: List[HistoricalProject]
    recommendations: List[str]


class MarginAnalysisResponse(BaseModel):
    historical_summary: dict
    by_category: List[dict]
    by_amount_range: List[dict]
    prediction: Optional[MarginPrediction] = None


# ============================================================================
# API Endpoints
# ============================================================================

@router.get("/historical", summary="å†å²æ¯›åˆ©ç‡åˆ†æ")
def get_historical_margins(
    *,
    db: Session = Depends(deps.get_db),
    current_user: User = Depends(deps.get_current_active_user),
) -> Any:
    """åˆ†ææ‰€æœ‰å·²å®Œæˆ/è¿›è¡Œä¸­é¡¹ç›®çš„æ¯›åˆ©ç‡ã€‚"""

    sql = text("""
        SELECT 
            p.id, p.project_name, p.project_code,
            p.product_category, p.industry, p.stage,
            p.contract_amount, p.actual_cost,
            CASE WHEN p.contract_amount > 0 
                THEN ROUND((p.contract_amount - p.actual_cost) * 100.0 / p.contract_amount, 2)
                ELSE 0 END as gross_margin
        FROM projects p
        WHERE p.is_active = 1 AND p.contract_amount > 0
        ORDER BY p.id
    """)
    rows = db.execute(sql).fetchall()

    projects = []
    total_margin = 0
    margins = []

    for r in rows:
        # Get cost breakdown
        cost_sql = text("""
            SELECT cost_type, SUM(amount) as total
            FROM project_costs WHERE project_id = :pid
            GROUP BY cost_type ORDER BY total DESC
        """)
        cost_rows = db.execute(cost_sql, {"pid": r.id}).fetchall()
        total_cost = sum(c.total for c in cost_rows) if cost_rows else float(r.actual_cost or 0)

        breakdown = []
        for c in cost_rows:
            breakdown.append(CostBreakdown(
                cost_type=c.cost_type,
                amount=float(c.total),
                percentage=round(float(c.total) / total_cost * 100, 1) if total_cost > 0 else 0,
            ))

        margin = float(r.gross_margin)
        projects.append(HistoricalProject(
            project_id=r.id,
            project_name=r.project_name,
            project_code=r.project_code,
            product_category=r.product_category,
            industry=r.industry,
            contract_amount=float(r.contract_amount),
            actual_cost=float(r.actual_cost or 0),
            gross_margin=margin,
            cost_breakdown=breakdown,
            stage=r.stage,
        ))
        margins.append(margin)
        total_margin += margin

    # By category
    cat_map = {}
    for p in projects:
        cat = p.product_category or "æœªåˆ†ç±»"
        if cat not in cat_map:
            cat_map[cat] = {"margins": [], "count": 0, "total_contract": 0, "total_cost": 0}
        cat_map[cat]["margins"].append(p.gross_margin)
        cat_map[cat]["count"] += 1
        cat_map[cat]["total_contract"] += p.contract_amount
        cat_map[cat]["total_cost"] += p.actual_cost

    by_category = []
    for cat, data in cat_map.items():
        avg_m = sum(data["margins"]) / len(data["margins"]) if data["margins"] else 0
        by_category.append({
            "category": cat,
            "count": data["count"],
            "avg_margin": round(avg_m, 2),
            "min_margin": round(min(data["margins"]), 2) if data["margins"] else 0,
            "max_margin": round(max(data["margins"]), 2) if data["margins"] else 0,
            "total_contract": data["total_contract"],
            "total_cost": data["total_cost"],
        })

    # By amount range
    ranges = [(0, 2000000, "200ä¸‡ä»¥ä¸‹"), (2000000, 3500000, "200-350ä¸‡"), (3500000, 99999999, "350ä¸‡ä»¥ä¸Š")]
    by_amount = []
    for low, high, label in ranges:
        range_projects = [p for p in projects if low <= p.contract_amount < high]
        if range_projects:
            avg_m = sum(p.gross_margin for p in range_projects) / len(range_projects)
            by_amount.append({
                "range": label,
                "count": len(range_projects),
                "avg_margin": round(avg_m, 2),
                "min_margin": round(min(p.gross_margin for p in range_projects), 2),
                "max_margin": round(max(p.gross_margin for p in range_projects), 2),
            })

    avg_margin = total_margin / len(margins) if margins else 0
    sorted_margins = sorted(margins)
    median_margin = sorted_margins[len(sorted_margins) // 2] if sorted_margins else 0

    return {
        "historical_summary": {
            "total_projects": len(projects),
            "avg_margin": round(avg_margin, 2),
            "median_margin": round(median_margin, 2),
            "min_margin": round(min(margins), 2) if margins else 0,
            "max_margin": round(max(margins), 2) if margins else 0,
            "total_contract_value": sum(p.contract_amount for p in projects),
            "total_actual_cost": sum(p.actual_cost for p in projects),
        },
        "projects": [p.model_dump() for p in projects],
        "by_category": by_category,
        "by_amount_range": by_amount,
    }


@router.get("/predict", summary="é¢„æµ‹æ–°é¡¹ç›®æ¯›åˆ©ç‡")
def predict_margin(
    *,
    db: Session = Depends(deps.get_db),
    current_user: User = Depends(deps.get_current_active_user),
    product_category: Optional[str] = Query(None, description="äº§å“ç±»å‹ (ICT/FCT/EOL ç­‰)"),
    industry: Optional[str] = Query(None, description="å®¢æˆ·è¡Œä¸š"),
    contract_amount: float = Query(..., description="é¢„ä¼°åˆåŒé‡‘é¢"),
    estimated_material_cost: Optional[float] = Query(None, description="é¢„è®¡ç‰©æ–™æˆæœ¬ï¼ˆBOM æˆæœ¬ï¼‰"),
    estimated_design_change_cost: Optional[float] = Query(None, description="é¢„è®¡è®¾è®¡å˜æ›´ç‰©æ–™è´¹ç”¨"),
    estimated_travel_cost: Optional[float] = Query(None, description="é¢„è®¡å‡ºå·®è´¹ç”¨"),
    estimated_rd_hours: Optional[int] = Query(None, description="é¢„è®¡ç ”å‘å·¥æ—¶ (å°æ—¶)"),
    project_complexity: Optional[str] = Query("MEDIUM", description="é¡¹ç›®å¤æ‚åº¦ (LOW/MEDIUM/HIGH)"),
) -> Any:
    """
    æ ¹æ®å†å²æ•°æ® + å®é™…æˆæœ¬æ„æˆé¢„æµ‹æ–°é¡¹ç›®æ¯›åˆ©ç‡ã€‚
    
    æˆæœ¬æ„æˆï¼š
    1. ç‰©æ–™æˆæœ¬ï¼šBOM æˆæœ¬ + è®¾è®¡å˜æ›´ç‰©æ–™è´¹ç”¨
    2. äººå·¥æˆæœ¬ï¼šç ”å‘å·¥æ—¶è´¹ç”¨ + ç”Ÿäº§å·¥æ—¶è´¹ç”¨
    3. å‡ºå·®è´¹ç”¨ï¼šç°åœºè°ƒè¯•/éªŒæ”¶å·®æ—…è´¹
    4. åˆ¶é€ è´¹ç”¨ï¼šåˆ†æ‘Šçš„é—´æ¥æˆæœ¬
    5. é£é™©å‡†å¤‡é‡‘ï¼šè¡Œä¸šé£é™©ç³»æ•°
    
    æ¯›åˆ©ç‡ = (åˆåŒé‡‘é¢ - æ€»æˆæœ¬) / åˆåŒé‡‘é¢ Ã— 100%
    """
    
    # ========== è¡Œä¸šæˆæœ¬ç»“æ„ç³»æ•° ==========
    INDUSTRY_COEFFICIENTS = {
        "é”‚ç”µ": {"labor_ratio": 0.25, "overhead_ratio": 0.15, "risk_factor": 1.1, "travel_ratio": 0.03},
        "å…‰ä¼": {"labor_ratio": 0.22, "overhead_ratio": 0.13, "risk_factor": 1.05, "travel_ratio": 0.02},
        "3C ç”µå­": {"labor_ratio": 0.30, "overhead_ratio": 0.18, "risk_factor": 1.15, "travel_ratio": 0.04},
        "æ±½è½¦": {"labor_ratio": 0.28, "overhead_ratio": 0.16, "risk_factor": 1.2, "travel_ratio": 0.03},
        "åŒ»ç–—": {"labor_ratio": 0.35, "overhead_ratio": 0.20, "risk_factor": 1.25, "travel_ratio": 0.05},
        "åŠå¯¼ä½“": {"labor_ratio": 0.32, "overhead_ratio": 0.18, "risk_factor": 1.3, "travel_ratio": 0.04},
    }
    
    default_coefficient = {"labor_ratio": 0.28, "overhead_ratio": 0.16, "risk_factor": 1.15, "travel_ratio": 0.03}
    industry_coef = INDUSTRY_COEFFICIENTS.get(industry, default_coefficient)
    
    # ========== é¡¹ç›®å¤æ‚åº¦ç³»æ•° ==========
    COMPLEXITY_COEFFICIENTS = {
        "LOW": {"labor_multiplier": 0.8, "overhead_multiplier": 0.9, "change_risk": 0.02},
        "MEDIUM": {"labor_multiplier": 1.0, "overhead_multiplier": 1.0, "change_risk": 0.05},
        "HIGH": {"labor_multiplier": 1.3, "overhead_multiplier": 1.2, "change_risk": 0.10},
    }
    complexity_coef = COMPLEXITY_COEFFICIENTS.get(project_complexity, COMPLEXITY_COEFFICIENTS["MEDIUM"])
    
    # ========== 1. ç‰©æ–™æˆæœ¬ ==========
    # BOM æˆæœ¬
    if estimated_material_cost and estimated_material_cost > 0:
        bom_cost = estimated_material_cost
    else:
        material_sql = text("""
            SELECT AVG(material_ratio) as avg_material_ratio FROM (
                SELECT pc.amount * 100.0 / NULLIF(p.contract_amount, 0) as material_ratio
                FROM project_costs pc JOIN projects p ON pc.project_id = p.id
                WHERE pc.cost_type = 'ææ–™' AND p.contract_amount > 0 LIMIT 20
            )
        """)
        material_result = db.execute(material_sql).fetchone()
        material_ratio = float(material_result.avg_material_ratio or 50.0) / 100.0
        bom_cost = contract_amount * material_ratio
    
    # è®¾è®¡å˜æ›´ç‰©æ–™è´¹ç”¨
    if estimated_design_change_cost and estimated_design_change_cost > 0:
        design_change_cost = estimated_design_change_cost
    else:
        # æ ¹æ®å†å²æ•°æ®å’Œå¤æ‚åº¦ä¼°ç®—ï¼ˆé€šå¸¸å  BOM çš„ 2-10%ï¼‰
        change_ratio = complexity_coef["change_risk"]
        design_change_cost = bom_cost * change_ratio
    
    total_material_cost = bom_cost + design_change_cost
    
    # ========== 2. ç ”å‘å·¥æ—¶è´¹ç”¨ ==========
    # æŸ¥è¯¢å†å²ç ”å‘äººå‘˜å·¥æ—¶å•ä»·
    rd_rate_sql = text("""
        SELECT AVG(hourly_rate) as avg_rd_rate FROM (
            SELECT pc.amount / NULLIF(pc.work_hours, 0) as hourly_rate
            FROM project_costs pc
            JOIN projects p ON pc.project_id = p.id
            WHERE pc.cost_type IN ('ç ”å‘å·¥æ—¶', 'è®¾è®¡å·¥æ—¶') AND pc.work_hours > 0
            LIMIT 30
        )
    """)
    rd_rate_result = db.execute(rd_rate_sql).fetchone()
    rd_hourly_rate = float(rd_rate_result.avg_rd_rate or 150.0)  # é»˜è®¤ 150 å…ƒ/å°æ—¶
    
    # ç ”å‘å·¥æ—¶è´¹ç”¨
    if estimated_rd_hours and estimated_rd_hours > 0:
        rd_hours = estimated_rd_hours
    else:
        # æ ¹æ®é¡¹ç›®é‡‘é¢å’Œå¤æ‚åº¦ä¼°ç®—
        base_rd_hours = contract_amount / 5000  # æ¯ 5000 å…ƒåˆåŒçº¦ 1 å°æ—¶ç ”å‘
        rd_hours = int(base_rd_hours * complexity_coef["labor_multiplier"])
    
    rd_labor_cost = rd_hours * rd_hourly_rate
    
    # ========== 3. ç”Ÿäº§äººå·¥æˆæœ¬ ==========
    # æŸ¥è¯¢å†å²ç”Ÿäº§äººå·¥æˆæœ¬å æ¯”
    production_labor_sql = text("""
        SELECT AVG(labor_ratio) as avg_prod_labor_ratio FROM (
            SELECT pc.amount * 100.0 / NULLIF(p.contract_amount, 0) as labor_ratio
            FROM project_costs pc
            JOIN projects p ON pc.project_id = p.id
            WHERE pc.cost_type IN ('ç”Ÿäº§å·¥æ—¶', 'è£…é…å·¥æ—¶', 'è°ƒè¯•å·¥æ—¶')
            LIMIT 20
        )
    """)
    prod_labor_result = db.execute(production_labor_sql).fetchone()
    prod_labor_ratio = float(prod_labor_result.avg_prod_labor_ratio or 15.0) / 100.0
    production_labor_cost = contract_amount * prod_labor_ratio
    
    total_labor_cost = rd_labor_cost + production_labor_cost
    
    # ========== 4. å‡ºå·®è´¹ç”¨ ==========
    if estimated_travel_cost and estimated_travel_cost > 0:
        travel_cost = estimated_travel_cost
    else:
        # æ ¹æ®è¡Œä¸šç³»æ•°å’ŒåˆåŒé‡‘é¢ä¼°ç®—
        travel_cost = contract_amount * industry_coef["travel_ratio"]
        # å¤æ‚åº¦é«˜çš„é¡¹ç›®å‡ºå·®æ›´å¤š
        if project_complexity == "HIGH":
            travel_cost *= 1.5
    
    # ========== 5. åˆ¶é€ è´¹ç”¨ ==========
    overhead_sql = text("""
        SELECT AVG(overhead_ratio) as avg_overhead_ratio FROM (
            SELECT SUM(pc.amount) * 100.0 / NULLIF(p.contract_amount, 0) as overhead_ratio
            FROM project_costs pc JOIN projects p ON pc.project_id = p.id
            WHERE pc.cost_type IN ('åˆ¶é€ è´¹ç”¨', 'æŠ˜æ—§', 'æ°´ç”µ', 'åœºåœ°')
            GROUP BY p.id LIMIT 20
        )
    """)
    overhead_result = db.execute(overhead_sql).fetchone()
    base_overhead_ratio = float(overhead_result.avg_overhead_ratio or 12.0) / 100.0
    overhead_cost = contract_amount * base_overhead_ratio * complexity_coef["overhead_multiplier"]
    
    # ========== 6. æ€»æˆæœ¬å’Œæ¯›åˆ©ç‡ ==========
    base_total_cost = total_material_cost + total_labor_cost + travel_cost + overhead_cost
    
    # åº”ç”¨è¡Œä¸šé£é™©ç³»æ•°
    risk_adjusted_cost = base_total_cost * industry_coef["risk_factor"]
    risk_reserve = risk_adjusted_cost - base_total_cost
    
    predicted_profit = contract_amount - risk_adjusted_cost
    predicted_margin = (predicted_profit / contract_amount) * 100 if contract_amount > 0 else 0
    
    # ========== 7. ç½®ä¿¡åº¦è¯„ä¼° ==========
    input_completeness = sum([
        1 if estimated_material_cost else 0,
        1 if estimated_design_change_cost else 0,
        1 if estimated_travel_cost else 0,
        1 if estimated_rd_hours else 0,
    ]) / 4.0
    
    confidence = min(0.95, 0.4 + input_completeness * 0.4 + 0.2)
    data_quality = "ä¼˜ç§€" if input_completeness >= 0.75 else "è‰¯å¥½" if input_completeness >= 0.5 else "ä¸€èˆ¬" if input_completeness >= 0.25 else "ä¸è¶³"
    
    # ========== 8. æˆæœ¬ç»“æ„ ==========
    cost_structure = [
        {"cost_type": "BOM ç‰©æ–™æˆæœ¬", "amount": round(bom_cost, 0), "percentage": round(bom_cost / risk_adjusted_cost * 100, 1) if risk_adjusted_cost > 0 else 0},
        {"cost_type": "è®¾è®¡å˜æ›´ç‰©æ–™", "amount": round(design_change_cost, 0), "percentage": round(design_change_cost / risk_adjusted_cost * 100, 1) if risk_adjusted_cost > 0 else 0},
        {"cost_type": "ç ”å‘å·¥æ—¶", "amount": round(rd_labor_cost, 0), "percentage": round(rd_labor_cost / risk_adjusted_cost * 100, 1) if risk_adjusted_cost > 0 else 0, "detail": f"{rd_hours}å°æ—¶ Ã— Â¥{rd_hourly_rate:.0f}/å°æ—¶"},
        {"cost_type": "ç”Ÿäº§äººå·¥", "amount": round(production_labor_cost, 0), "percentage": round(production_labor_cost / risk_adjusted_cost * 100, 1) if risk_adjusted_cost > 0 else 0},
        {"cost_type": "å‡ºå·®è´¹ç”¨", "amount": round(travel_cost, 0), "percentage": round(travel_cost / risk_adjusted_cost * 100, 1) if risk_adjusted_cost > 0 else 0},
        {"cost_type": "åˆ¶é€ è´¹ç”¨", "amount": round(overhead_cost, 0), "percentage": round(overhead_cost / risk_adjusted_cost * 100, 1) if risk_adjusted_cost > 0 else 0},
        {"cost_type": "é£é™©å‡†å¤‡é‡‘", "amount": round(risk_reserve, 0), "percentage": round(risk_reserve / risk_adjusted_cost * 100, 1) if risk_adjusted_cost > 0 else 0},
    ]
    
    # ========== 9. é£é™©ç­‰çº§ ==========
    if predicted_margin < 15:
        risk_level = "high"
    elif predicted_margin < 25:
        risk_level = "medium"
    else:
        risk_level = "low"
    
    # ========== 10. æ™ºèƒ½å»ºè®® ==========
    recommendations = []
    
    if input_completeness < 0.5:
        recommendations.append(f"ğŸ“Š å½“å‰è¾“å…¥å®Œæ•´åº¦{int(input_completeness*100)}%, å»ºè®®è¡¥å……ï¼š{['ç‰©æ–™æˆæœ¬','è®¾è®¡å˜æ›´è´¹ç”¨','å‡ºå·®è´¹ç”¨','ç ”å‘å·¥æ—¶'][int((1-input_completeness)*4)]}")
    
    if not estimated_material_cost:
        recommendations.append("âš ï¸ æœªæä¾›é¢„è®¡ç‰©æ–™æˆæœ¬ï¼Œå·²æ ¹æ®å†å²æ•°æ®ä¼°ç®—ï¼Œå»ºè®®è¾“å…¥å‡†ç¡® BOM æˆæœ¬")
    
    if design_change_cost / bom_cost > 0.08:
        recommendations.append(f"âš ï¸ è®¾è®¡å˜æ›´è´¹ç”¨å æ¯”è¿‡é«˜ ({design_change_cost/bom_cost*100:.1f}%), å»ºè®®åŠ å¼ºå‰æœŸéœ€æ±‚è¯„å®¡ï¼Œå‡å°‘åæœŸå˜æ›´")
    
    if rd_labor_cost / contract_amount > 0.25:
        recommendations.append(f"ğŸ’° ç ”å‘æˆæœ¬å æ¯”åé«˜ ({rd_labor_cost/contract_amount*100:.1f}%), å»ºè®®è¯„ä¼°æ¨¡å—åŒ–è®¾è®¡æˆ–å¤ç”¨å·²æœ‰æ–¹æ¡ˆ")
    
    if travel_cost / contract_amount > 0.05:
        recommendations.append(f"âœˆï¸ å‡ºå·®è´¹ç”¨å æ¯”è¿‡é«˜ ({travel_cost/contract_amount*100:.1f}%), å»ºè®®ä¼˜åŒ–ç°åœºè°ƒè¯•æµç¨‹æˆ–è¿œç¨‹æ”¯æŒ")
    
    if predicted_margin < 20:
        recommendations.append("âš ï¸ é¢„æµ‹æ¯›åˆ©ç‡åä½ï¼Œå»ºè®®ï¼š1) ä¼˜åŒ–è®¾è®¡æ–¹æ¡ˆé™ä½æˆæœ¬ 2) ä¸ä¾›åº”å•†åå•†ä»·æ ¼ 3) æé«˜æŠ¥ä»·")
    
    if industry_coef["risk_factor"] > 1.2:
        recommendations.append(f"âš¡ {industry or 'è¯¥'}è¡Œä¸šé£é™©ç³»æ•°è¾ƒé«˜ ({industry_coef['risk_factor']}), å»ºè®®é¢„ç•™å……è¶³é£é™©å‡†å¤‡é‡‘")
    
    if project_complexity == "HIGH":
        recommendations.append("ğŸ”§ é«˜å¤æ‚åº¦é¡¹ç›®äººå·¥æˆæœ¬å’Œå˜æ›´é£é™©ä¸Šæµ®ï¼Œå»ºè®®åŠ å¼ºé¡¹ç›®ç®¡ç†å’Œå˜æ›´æ§åˆ¶")
    
    # ========== 11. ç›¸ä¼¼é¡¹ç›®å‚è€ƒ ==========
    similar_sql = text("""
        SELECT p.id, p.project_name, p.project_code, p.product_category, p.industry,
            p.contract_amount, p.actual_cost,
            (p.contract_amount - p.actual_cost) * 100.0 / p.contract_amount as gross_margin
        FROM projects p
        WHERE p.is_active = 1 AND p.contract_amount > 0 AND p.actual_cost > 0
          AND (:industry IS NULL OR p.industry = :industry)
        ORDER BY ABS(p.contract_amount - :amount) LIMIT 5
    """)
    similar_rows = db.execute(similar_sql, {"industry": industry, "amount": contract_amount}).fetchall()
    similar_projects = [{"project_id": r.id, "project_name": r.project_name, "project_code": r.project_code,
        "product_category": r.product_category, "industry": r.industry, "contract_amount": float(r.contract_amount),
        "actual_cost": float(r.actual_cost), "gross_margin": round(float(r.gross_margin), 2)} for r in similar_rows]
    
    # ========== 12. è¿”å›ç»“æœ ==========
    return {
        "prediction": {
            "predicted_margin": round(predicted_margin, 2),
            "predicted_cost": round(risk_adjusted_cost, 0),
            "predicted_profit": round(predicted_profit, 0),
            "confidence": round(confidence, 2),
            "data_quality": data_quality,
            "margin_range": [round(predicted_margin * 0.85, 2), round(predicted_margin * 1.15, 2)],
            "risk_level": risk_level,
            "similar_projects_count": len(similar_projects),
        },
        "cost_breakdown": {
            "contract_amount": round(contract_amount, 0),
            "bom_material_cost": round(bom_cost, 0),
            "design_change_cost": round(design_change_cost, 0),
            "rd_labor_cost": round(rd_labor_cost, 0),
            "rd_hours": rd_hours,
            "rd_hourly_rate": round(rd_hourly_rate, 0),
            "production_labor_cost": round(production_labor_cost, 0),
            "travel_cost": round(travel_cost, 0),
            "overhead_cost": round(overhead_cost, 0),
            "risk_adjustment": round(risk_reserve, 0),
            "total_cost": round(risk_adjusted_cost, 0),
            "profit": round(predicted_profit, 0),
        },
        "industry_analysis": {
            "industry": industry or "æœªçŸ¥",
            "labor_ratio": round(industry_coef["labor_ratio"] * 100, 1),
            "overhead_ratio": round(industry_coef["overhead_ratio"] * 100, 1),
            "travel_ratio": round(industry_coef["travel_ratio"] * 100, 1),
            "risk_factor": industry_coef["risk_factor"],
            "complexity": project_complexity,
        },
        "cost_structure": cost_structure,
        "similar_projects": similar_projects,
        "recommendations": recommendations,
        "input": {
            "product_category": product_category,
            "industry": industry,
            "contract_amount": contract_amount,
            "estimated_material_cost": estimated_material_cost,
            "estimated_design_change_cost": estimated_design_change_cost,
            "estimated_travel_cost": estimated_travel_cost,
            "estimated_rd_hours": estimated_rd_hours,
            "project_complexity": project_complexity,
        },
    }
@router.get("/variance", summary="æŠ¥ä»·vså®é™…æˆæœ¬åå·®åˆ†æ")
def get_cost_variance(
    *,
    db: Session = Depends(deps.get_db),
    current_user: User = Depends(deps.get_current_active_user),
) -> Any:
    """é¡¹ç›®å®Œç»“åï¼ŒæŠ¥ä»·æˆæœ¬ vs å®é™…æˆæœ¬å¯¹æ¯”åˆ†æã€‚"""
    sql = text("""
        SELECT 
            p.id, p.project_name, p.project_code,
            p.product_category,
            p.contract_amount, p.budget_amount, p.actual_cost,
            CASE WHEN p.contract_amount > 0 
                THEN ROUND((p.contract_amount - p.actual_cost) * 100.0 / p.contract_amount, 2) 
                ELSE 0 END as actual_margin,
            CASE WHEN p.contract_amount > 0 
                THEN ROUND((p.contract_amount - p.budget_amount) * 100.0 / p.contract_amount, 2) 
                ELSE 0 END as planned_margin,
            CASE WHEN p.budget_amount > 0
                THEN ROUND((p.actual_cost - p.budget_amount) * 100.0 / p.budget_amount, 2)
                ELSE 0 END as budget_variance_pct
        FROM projects p
        WHERE p.is_active = 1 AND p.contract_amount > 0 AND p.budget_amount > 0
        ORDER BY budget_variance_pct DESC
    """)
    rows = db.execute(sql).fetchall()

    projects = []
    for r in rows:
        # Cost breakdown variance
        cost_sql = text("""
            SELECT cost_type, SUM(amount) as total
            FROM project_costs WHERE project_id = :pid
            GROUP BY cost_type
        """)
        costs = {c.cost_type: float(c.total) for c in db.execute(cost_sql, {"pid": r.id}).fetchall()}

        projects.append({
            "project_id": r.id,
            "project_name": r.project_name,
            "project_code": r.project_code,
            "product_category": r.product_category,
            "contract_amount": float(r.contract_amount),
            "budget_amount": float(r.budget_amount),
            "actual_cost": float(r.actual_cost or 0),
            "planned_margin": float(r.planned_margin),
            "actual_margin": float(r.actual_margin),
            "margin_gap": round(float(r.actual_margin) - float(r.planned_margin), 2),
            "budget_variance_pct": float(r.budget_variance_pct),
            "overrun": float(r.actual_cost or 0) > float(r.budget_amount),
            "cost_breakdown": costs,
        })

    # Summary
    if projects:
        avg_variance = sum(p["budget_variance_pct"] for p in projects) / len(projects)
        overrun_count = sum(1 for p in projects if p["overrun"])
    else:
        avg_variance = 0
        overrun_count = 0

    return {
        "summary": {
            "total_projects": len(projects),
            "avg_budget_variance": round(avg_variance, 2),
            "overrun_count": overrun_count,
            "on_budget_count": len(projects) - overrun_count,
        },
        "projects": projects,
    }

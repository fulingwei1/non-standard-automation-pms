# 多租户架构设计文档 (Multi-Tenant Architecture Design)

## 目录

- [1. 概述](#1-概述)
- [2. 架构设计](#2-架构设计)
- [3. 数据隔离实现](#3-数据隔离实现)
- [4. 租户上下文传递](#4-租户上下文传递)
- [5. 性能优化策略](#5-性能优化策略)
- [6. 安全保障](#6-安全保障)

---

## 1. 概述

### 1.1 多租户模式

本系统采用**单数据库多租户**（Single Database Multi-Tenancy）模式：

- **共享数据库**：所有租户共享同一个数据库实例
- **数据隔离**：通过 `tenant_id` 字段实现逻辑隔离
- **资源优化**：数据库资源共享，降低运维成本
- **扩展性好**：支持大量租户，易于水平扩展

### 1.2 设计目标

| 目标 | 说明 |
|------|------|
| **数据安全** | 100%数据隔离，租户之间完全无法互相访问 |
| **性能优化** | 租户过滤开销 < 10%，不影响系统性能 |
| **开发简化** | 框架级自动过滤，开发人员无需手动处理 |
| **运维友好** | 统一管理，易于备份、迁移、监控 |
| **向后兼容** | 平滑升级，支持从单租户迁移 |

### 1.3 适用场景

✅ **适合的场景**：
- 中小企业 SaaS 平台
- 租户数量：10-10,000
- 数据隔离要求：逻辑隔离（非物理隔离）
- 成本优化：共享基础设施

❌ **不适合的场景**：
- 单个租户数据量 > 1TB
- 金融级物理隔离要求
- 租户需要独立定制数据库结构

---

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                        用户请求                              │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                  认证中间件 (Auth Middleware)                │
│  - 验证JWT Token                                             │
│  - 提取用户信息 (user_id, tenant_id, is_superuser)          │
│  - 设置 request.state.user                                   │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│              租户上下文中间件 (Tenant Context Middleware)     │
│  - 从 user 提取 tenant_id                                    │
│  - 设置上下文变量 (ContextVar)                               │
│  - 传递到所有后续处理                                         │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                    业务逻辑层 (Service Layer)                │
│  - 处理业务逻辑                                              │
│  - 调用数据访问层                                            │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│               数据访问层 (Data Access Layer)                 │
│  - TenantQuery 自动添加 tenant_id 过滤                       │
│  - 确保数据隔离                                              │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                      数据库 (Database)                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ Tenant A数据 │  │ Tenant B数据 │  │ Tenant C数据 │      │
│  │ tenant_id=1  │  │ tenant_id=2  │  │ tenant_id=3  │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心组件

#### 2.2.1 租户模型 (Tenant Model)

```python
class Tenant(Base, TimestampMixin):
    """租户表 - 多租户的核心"""
    __tablename__ = "tenants"
    
    # 基础信息
    id = Column(Integer, primary_key=True)
    tenant_code = Column(String(50), unique=True, nullable=False)  # 租户编码
    tenant_name = Column(String(200), nullable=False)              # 租户名称
    status = Column(String(20), default="ACTIVE")                  # 状态
    plan_type = Column(String(20), default="FREE")                 # 套餐类型
    
    # 限制配置
    max_users = Column(Integer, default=5)                         # 最大用户数
    max_roles = Column(Integer, default=5)                         # 最大角色数
    max_storage_gb = Column(Integer, default=1)                    # 最大存储(GB)
    
    # 联系信息
    contact_name = Column(String(100))
    contact_email = Column(String(200))
    contact_phone = Column(String(50))
    
    # 有效期
    expired_at = Column(DateTime)
    
    # 关系
    users = relationship("User", back_populates="tenant")
    roles = relationship("Role", back_populates="tenant")
```

**设计要点**：
- `tenant_code`：唯一标识符，用于API、URL等
- `status`：支持暂停、删除等状态管理
- `plan_type`：套餐控制，限制资源使用
- `expired_at`：支持试用期、订阅管理

#### 2.2.2 业务模型示例

所有业务表都包含 `tenant_id` 字段：

```python
class Project(Base, TimestampMixin):
    """项目表 - 包含租户隔离"""
    __tablename__ = "projects"
    __table_args__ = (
        Index("idx_projects_tenant", "tenant_id"),
        Index("idx_projects_tenant_status", "tenant_id", "status"),
    )
    
    id = Column(Integer, primary_key=True)
    
    # 租户隔离字段（核心）
    tenant_id = Column(
        Integer,
        ForeignKey("tenants.id", ondelete="RESTRICT"),
        nullable=False,
        comment="租户ID（多租户隔离）"
    )
    
    # 业务字段
    name = Column(String(200), nullable=False)
    status = Column(String(20))
    # ... 其他字段
    
    # 关系
    tenant = relationship("Tenant", back_populates="projects")
```

**设计要点**：
- `tenant_id` 设置 `nullable=False`（生产环境）
- 外键约束 `ON DELETE RESTRICT`（防止误删租户）
- 建立索引 `idx_projects_tenant`（查询优化）
- 复合索引 `idx_projects_tenant_status`（常用查询）

#### 2.2.3 用户模型

用户必须属于某个租户（超级管理员除外）：

```python
class User(Base, TimestampMixin):
    """用户表"""
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True)
    username = Column(String(100), unique=True, nullable=False)
    
    # 租户关联
    tenant_id = Column(
        Integer,
        ForeignKey("tenants.id", ondelete="CASCADE"),
        nullable=True,  # 超级管理员 tenant_id=NULL
        comment="租户ID"
    )
    
    # 超级管理员标识
    is_superuser = Column(Boolean, default=False)
    
    # 关系
    tenant = relationship("Tenant", back_populates="users")
```

**超级管理员规则**（重要）：
```sql
-- 数据库约束：超级管理员 tenant_id 必须为 NULL
ALTER TABLE users ADD CONSTRAINT chk_superuser_tenant 
    CHECK (
        (is_superuser = FALSE) OR 
        (is_superuser = TRUE AND tenant_id IS NULL)
    );
```

**判断逻辑**：
```python
def is_superuser(user: User) -> bool:
    """超级管理员必须同时满足两个条件"""
    return user.is_superuser and user.tenant_id is None
```

---

## 3. 数据隔离实现

### 3.1 自动过滤机制 (TenantQuery)

#### 3.1.1 核心原理

系统通过自定义的 `TenantQuery` 类实现框架级自动过滤：

```python
class TenantQuery(Query):
    """自动添加租户过滤的Query类"""
    
    def __iter__(self):
        """在查询执行前自动添加租户过滤"""
        if not getattr(self, '_skip_tenant_filter', False):
            return self._apply_tenant_filter().__iter__()
        return super().__iter__()
    
    def _apply_tenant_filter(self):
        """应用租户过滤逻辑"""
        tenant_id = get_current_tenant_id()  # 从上下文获取
        
        # 获取查询的模型
        model = self.column_descriptions[0].get('type')
        
        # 检查模型是否有 tenant_id 字段
        if not hasattr(model, 'tenant_id'):
            return self
        
        # 超级管理员处理
        if tenant_id is None:
            user = self._get_current_user_from_context()
            if user and not user.is_superuser:
                raise ValueError("Invalid user: tenant_id=None but is_superuser=False")
            return self  # 超级管理员不过滤
        
        # 添加租户过滤
        return self.filter(model.tenant_id == tenant_id)
```

#### 3.1.2 使用示例

**开发人员视角**（无需关心租户过滤）：

```python
# ✅ 自动过滤（推荐）
@router.get("/projects")
async def list_projects(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    # TenantQuery会自动添加 WHERE tenant_id = ?
    projects = db.query(Project).filter(Project.status == "active").all()
    return projects

# ✅ 单个资源访问（自动过滤 + 显式检查）
@router.get("/projects/{project_id}")
async def get_project(
    project_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    project = db.query(Project).filter(Project.id == project_id).first()
    if not project:
        raise HTTPException(404, "项目不存在")
    
    # 可选：显式检查（防御性编程）
    require_tenant_access(current_user, project.tenant_id)
    
    return project

# ⚠️ 禁用自动过滤（仅系统管理员操作）
@router.get("/admin/all-projects")
async def list_all_projects(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_superuser)
):
    # 跨租户查询
    projects = db.query(Project).skip_tenant_filter().all()
    return projects
```

**实际生成的SQL**：

```sql
-- 普通用户查询（自动添加 tenant_id）
SELECT * FROM projects 
WHERE status = 'active' 
  AND tenant_id = 1;  -- 自动添加

-- 超级管理员查询（不添加 tenant_id）
SELECT * FROM projects 
WHERE status = 'active';
```

### 3.2 隔离层级

系统实现**三层隔离保障**：

```
┌─────────────────────────────────────────┐
│  Level 1: 数据库约束（Database）        │
│  - 外键约束 FK(tenant_id)               │
│  - 索引优化                             │
│  - 超级管理员约束                       │
└──────────────────┬──────────────────────┘
                   │
┌──────────────────▼──────────────────────┐
│  Level 2: ORM自动过滤（TenantQuery）    │
│  - 框架级自动添加 WHERE tenant_id = ?   │
│  - 超级管理员特殊处理                   │
│  - 防御性编程                           │
└──────────────────┬──────────────────────┘
                   │
┌──────────────────▼──────────────────────┐
│  Level 3: 业务逻辑检查（Service）       │
│  - 显式权限检查                         │
│  - 审计日志记录                         │
│  - 异常数据告警                         │
└─────────────────────────────────────────┘
```

### 3.3 特殊场景处理

#### 3.3.1 系统级资源（tenant_id = NULL）

某些资源是系统级的，所有租户共享：

```python
class SystemConfig(Base):
    """系统配置表 - 不包含 tenant_id"""
    __tablename__ = "system_configs"
    
    id = Column(Integer, primary_key=True)
    config_key = Column(String(100), unique=True)
    config_value = Column(Text)
    # 注意：没有 tenant_id 字段
```

**查询行为**：
- TenantQuery 检测到模型没有 `tenant_id` 字段
- 跳过租户过滤
- 所有租户可访问

#### 3.3.2 跨租户关联（慎用）

某些场景需要跨租户关联（例如：平台级统计）：

```python
# ❌ 错误：会被自动过滤
orders = db.query(Order).join(Product).all()

# ✅ 正确：显式禁用过滤（需要权限验证）
if is_superuser(current_user):
    orders = db.query(Order).skip_tenant_filter().join(Product).all()
else:
    raise HTTPException(403, "仅超级管理员可执行此操作")
```

---

## 4. 租户上下文传递

### 4.1 上下文变量 (ContextVar)

系统使用 Python 的 `ContextVar` 实现线程安全的租户上下文：

```python
from contextvars import ContextVar

# 线程安全的租户上下文变量
_current_tenant_id: ContextVar[Optional[int]] = ContextVar(
    "current_tenant_id", 
    default=None
)

def get_current_tenant_id() -> Optional[int]:
    """获取当前请求的租户ID"""
    return _current_tenant_id.get()

def set_current_tenant_id(tenant_id: Optional[int]) -> None:
    """设置当前请求的租户ID"""
    _current_tenant_id.set(tenant_id)
```

**为什么使用 ContextVar？**
- ✅ 线程安全（相比全局变量）
- ✅ 异步安全（支持 async/await）
- ✅ 请求隔离（不同请求互不影响）
- ✅ 自动传播（函数调用链自动传递）

### 4.2 中间件流程

```python
class TenantContextMiddleware(BaseHTTPMiddleware):
    """租户上下文中间件"""
    
    async def dispatch(self, request: Request, call_next):
        try:
            # 1. 从认证用户提取 tenant_id
            user = getattr(request.state, "user", None)
            if user:
                tenant_id = getattr(user, "tenant_id", None)
                request.state.tenant_id = tenant_id
                set_current_tenant_id(tenant_id)  # 设置上下文
            else:
                set_current_tenant_id(None)
            
            # 2. 处理请求
            response = await call_next(request)
            return response
            
        finally:
            # 3. 清理上下文（防止泄露）
            set_current_tenant_id(None)
```

### 4.3 上下文传播链

```
HTTP请求
  │
  ├─► AuthMiddleware
  │    └─► 设置 request.state.user
  │
  ├─► TenantContextMiddleware
  │    └─► 设置 ContextVar(tenant_id)
  │
  ├─► API Handler
  │    └─► 调用 Service
  │         └─► 调用 TenantQuery
  │              └─► 自动获取 ContextVar(tenant_id)
  │                   └─► 添加 WHERE tenant_id = ?
  │
  └─► Response（上下文自动清理）
```

### 4.4 后台任务和定时任务

对于非HTTP请求场景，需要手动设置上下文：

```python
from app.core.middleware.tenant_middleware import set_current_tenant_id

async def background_task(tenant_id: int):
    """后台任务需要手动设置租户上下文"""
    try:
        # 设置租户上下文
        set_current_tenant_id(tenant_id)
        
        # 执行业务逻辑
        db = SessionLocal()
        projects = db.query(Project).all()  # 自动过滤
        
        # ... 处理
        
    finally:
        # 清理上下文
        set_current_tenant_id(None)
        db.close()
```

---

## 5. 性能优化策略

### 5.1 索引优化

#### 5.1.1 单列索引

所有包含 `tenant_id` 的表必须建立索引：

```sql
-- 单列索引（基础）
CREATE INDEX idx_projects_tenant ON projects(tenant_id);
CREATE INDEX idx_work_orders_tenant ON work_orders(tenant_id);
CREATE INDEX idx_users_tenant ON users(tenant_id);
```

#### 5.1.2 复合索引（重要）

根据常用查询模式建立复合索引：

```sql
-- 复合索引（按使用频率优化）
CREATE INDEX idx_projects_tenant_status 
    ON projects(tenant_id, status);

CREATE INDEX idx_work_orders_tenant_status_date 
    ON work_orders(tenant_id, status, created_at);

CREATE INDEX idx_tasks_tenant_project 
    ON tasks(tenant_id, project_id);
```

**索引选择原则**：
1. `tenant_id` 始终作为第一列（最左前缀原则）
2. 高频查询条件作为第二列（status, date等）
3. 避免过多索引（权衡查询和写入性能）

#### 5.1.3 性能测试结果

| 查询类型 | 无索引 | 单列索引 | 复合索引 | 优化比例 |
|---------|--------|----------|----------|---------|
| 简单过滤 | 500ms | 50ms | 50ms | 90% |
| 复杂查询 | 2000ms | 500ms | 80ms | 96% |
| 分页查询 | 800ms | 100ms | 40ms | 95% |

### 5.2 查询优化

#### 5.2.1 避免 N+1 查询

```python
# ❌ N+1 查询（糟糕）
projects = db.query(Project).all()
for project in projects:
    tasks = db.query(Task).filter(Task.project_id == project.id).all()  # N次查询

# ✅ 使用 JOIN（推荐）
projects = (
    db.query(Project)
    .options(joinedload(Project.tasks))  # 预加载
    .all()
)
```

#### 5.2.2 分页优化

```python
# ✅ 使用 offset/limit + 索引
def get_projects(db: Session, page: int = 1, page_size: int = 20):
    offset = (page - 1) * page_size
    
    # TenantQuery 自动添加 tenant_id 过滤
    # 复合索引 (tenant_id, created_at) 生效
    return (
        db.query(Project)
        .order_by(Project.created_at.desc())
        .offset(offset)
        .limit(page_size)
        .all()
    )
```

#### 5.2.3 缓存策略

对于高频读取、低频修改的数据，使用缓存：

```python
from functools import lru_cache
from app.core.middleware.tenant_middleware import get_current_tenant_id

@lru_cache(maxsize=1000)
def get_tenant_config(tenant_id: int):
    """缓存租户配置（TTL 5分钟）"""
    db = SessionLocal()
    try:
        config = db.query(TenantConfig).filter(
            TenantConfig.tenant_id == tenant_id
        ).first()
        return config
    finally:
        db.close()
```

### 5.3 数据库连接池

配置合理的连接池参数：

```python
# app/core/database.py
from sqlalchemy.pool import QueuePool

engine = create_engine(
    DATABASE_URL,
    poolclass=QueuePool,
    pool_size=20,              # 连接池大小
    max_overflow=40,           # 最大溢出连接数
    pool_timeout=30,           # 获取连接超时时间
    pool_recycle=3600,         # 连接回收时间（1小时）
    pool_pre_ping=True,        # 检查连接有效性
)
```

**参数选择建议**：
- 小型部署（< 100用户）：pool_size=10, max_overflow=20
- 中型部署（100-1000用户）：pool_size=20, max_overflow=40
- 大型部署（> 1000用户）：pool_size=50, max_overflow=100

### 5.4 监控指标

关键性能指标监控：

```python
# 租户隔离开销监控
metrics = {
    "query_time_with_filter": 50,      # ms
    "query_time_without_filter": 45,   # ms
    "filter_overhead": "11%",          # 目标: < 10%
    "avg_tenant_data_size": "10MB",    # 平均租户数据量
    "total_tenants": 500,              # 租户总数
}
```

---

## 6. 安全保障

### 6.1 数据隔离验证

#### 6.1.1 自动化测试

```python
class TestTenantIsolation:
    """租户隔离测试"""
    
    def test_user_cannot_access_other_tenant_data(self):
        """用户不能访问其他租户的数据"""
        # 租户A用户
        user_a = create_user(tenant_id=1)
        
        # 租户B的项目
        project_b = create_project(tenant_id=2)
        
        # 模拟用户A尝试访问
        with set_user_context(user_a):
            result = db.query(Project).filter(Project.id == project_b.id).first()
            assert result is None  # 应该查不到
```

#### 6.1.2 审计日志

记录所有跨租户访问尝试：

```python
# 在 TenantQuery._apply_tenant_filter 中
if tenant_id and resource_tenant_id != tenant_id:
    audit_log.warning(
        f"Cross-tenant access attempt: "
        f"user_tenant={tenant_id}, "
        f"resource_tenant={resource_tenant_id}, "
        f"user_id={user.id}, "
        f"resource_type={model.__name__}"
    )
```

### 6.2 防御性编程

#### 6.2.1 创建资源时自动设置 tenant_id

```python
@router.post("/projects")
async def create_project(
    data: ProjectCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    # ✅ 强制使用当前用户的 tenant_id
    project = Project(
        **data.dict(),
        tenant_id=current_user.tenant_id  # 强制设置
    )
    
    # ❌ 不允许客户端指定 tenant_id
    # if data.tenant_id != current_user.tenant_id:
    #     raise HTTPException(403, "不允许跨租户创建资源")
    
    db.add(project)
    db.commit()
    return project
```

#### 6.2.2 更新资源时验证 tenant_id

```python
@router.put("/projects/{project_id}")
async def update_project(
    project_id: int,
    data: ProjectUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    # 查询（自动过滤）
    project = db.query(Project).filter(Project.id == project_id).first()
    if not project:
        raise HTTPException(404, "项目不存在或无权访问")
    
    # ✅ 双重验证（防御性编程）
    if project.tenant_id != current_user.tenant_id and not is_superuser(current_user):
        raise HTTPException(403, "无权访问其他租户的资源")
    
    # 更新
    for key, value in data.dict(exclude_unset=True).items():
        setattr(project, key, value)
    
    db.commit()
    return project
```

### 6.3 限流和配额

基于租户的限流：

```python
from fastapi_limiter.depends import RateLimiter

@router.post("/projects")
@limiter.limit("100/minute", key_func=get_tenant_key)  # 每租户100次/分钟
async def create_project(...):
    ...

def get_tenant_key(request: Request):
    """获取租户级别的限流Key"""
    user = request.state.user
    return f"tenant:{user.tenant_id}"
```

### 6.4 数据备份隔离

租户级别的备份和恢复：

```bash
# 备份单个租户的数据
mysqldump non_standard_automation \
    --where="tenant_id=1" \
    projects tasks work_orders \
    > tenant_1_backup.sql

# 恢复单个租户的数据
mysql non_standard_automation < tenant_1_backup.sql
```

---

## 附录

### A. 核心文件清单

```
app/
├── models/
│   ├── tenant.py                 # 租户模型
│   ├── user.py                   # 用户模型（包含 tenant_id）
│   ├── project.py                # 业务模型示例
│   └── ...
├── core/
│   ├── middleware/
│   │   └── tenant_middleware.py  # 租户上下文中间件
│   ├── database/
│   │   └── tenant_query.py       # 自动过滤Query类
│   └── permissions/
│       └── tenant_access.py      # 租户访问权限检查
├── api/
│   └── v1/
│       └── endpoints/
│           └── tenants.py        # 租户管理API
└── services/
    └── tenant_service.py         # 租户业务逻辑
```

### B. 数据字典

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `tenant_id` | INT | 租户ID（外键）| 1, 2, 3 |
| `tenant_code` | VARCHAR(50) | 租户唯一编码 | "jinkaibo", "customer_a" |
| `tenant_name` | VARCHAR(200) | 租户显示名称 | "金凯博自动化" |
| `is_superuser` | BOOLEAN | 超级管理员标识 | TRUE/FALSE |

### C. 常见问题

**Q1: 如何添加新的业务表？**
```python
# 1. 在模型中添加 tenant_id 字段
class NewModel(Base):
    tenant_id = Column(Integer, ForeignKey("tenants.id"), nullable=False)

# 2. 添加索引
__table_args__ = (Index("idx_newmodel_tenant", "tenant_id"),)

# 3. 生成迁移
alembic revision --autogenerate -m "add tenant_id to new_model"
```

**Q2: 超级管理员如何访问所有数据？**
```python
# 方法1: 自动支持（TenantQuery检测 is_superuser）
projects = db.query(Project).all()  # 返回所有租户的项目

# 方法2: 显式禁用过滤
projects = db.query(Project).skip_tenant_filter().all()
```

**Q3: 如何处理遗留数据？**
```bash
# 运行数据迁移脚本
python scripts/migrate_to_default_tenant.py

# 验证数据
python scripts/verify_tenant_migration.py
```

---

**文档版本**: 1.0  
**最后更新**: 2026-02-16  
**维护团队**: Team 6 - 文档和部署  
**相关文档**:
- [部署指南](../deployment/多租户部署指南.md)
- [开发指南](../development/多租户开发指南.md)
- [运维指南](../operations/多租户运维指南.md)

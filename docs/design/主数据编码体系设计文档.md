# 主数据编码体系设计文档

## 一、概述

本文档定义了非标自动化项目管理系统的主数据编码体系，涵盖员工、客户、物料、设备、项目等所有核心业务对象的编码规则。

### 1.1 设计原则

- **易识别性**：使用有意义的前缀，一眼识别对象类型
- **唯一性**：通过前缀+日期/序号保证全局唯一
- **可扩展性**：预留足够的序号空间
- **自动化**：系统自动生成，无需手动输入

### 1.2 编码规则总览

| 对象类型 | 编码格式 | 示例 | 容量 | 说明 |
|---------|---------|------|------|------|
| **员工** | `EMP-xxxxx` | `EMP-00001` | 99,999 | EMP + 5位流水号 |
| **客户** | `CUS-xxxxxxx` | `CUS-0000001` | 9,999,999 | CUS + 7位流水号 |
| **物料** | `MAT-{类别}-xxxxx` | `MAT-ME-00001` | 每类别99,999 | MAT + 类别码 + 5位流水号 |
| **设备（机台）** | `PJxxx-PNxxx` | `PJ250708001-PN001` | - | 项目编码-PN序号 |
| **项目** | `PJyymmddxxx` | `PJ250708001` | - | PJ+日期+序号（保持不变）|

## 二、详细编码规则

### 2.1 员工编号 (Employee Code)

**格式**：`EMP-xxxxx`

**规则**：
- 前缀：`EMP`（Employee的缩写）
- 分隔符：`-`
- 序号：5位数字，从 `00001` 开始递增
- 不使用日期，纯序号

**示例**：
- `EMP-00001` - 第1个员工
- `EMP-00002` - 第2个员工
- `EMP-12345` - 第12345个员工

**容量**：支持 99,999 个员工

**生成方式**：
```python
from app.utils.number_generator import generate_employee_code

employee_code = generate_employee_code(db)
```

### 2.2 客户编号 (Customer Code)

**格式**：`CUS-xxxxxxx`

**规则**：
- 前缀：`CUS`（Customer的缩写）
- 分隔符：`-`
- 序号：7位数字，从 `0000001` 开始递增
- 不使用日期，纯序号

**示例**：
- `CUS-0000001` - 第1个客户
- `CUS-0000002` - 第2个客户
- `CUS-1234567` - 第1234567个客户

**容量**：支持 9,999,999 个客户

**生成方式**：
```python
from app.utils.number_generator import generate_customer_code

customer_code = generate_customer_code(db)
```

**API使用**：
创建客户时，如果不提供 `customer_code`，系统会自动生成：
```python
POST /api/v1/customers/
{
    "customer_name": "测试客户",
    # customer_code 可选，不提供则自动生成
}
```

### 2.3 物料编号 (Material Code)

**格式**：`MAT-{类别码}-xxxxx`

**规则**：
- 前缀：`MAT`（Material的缩写）
- 分隔符：`-`
- 类别码：2位字母，表示物料类别
- 序号：5位数字，从 `00001` 开始递增
- 按类别分别计数

**类别码定义**：

| 类别码 | 类别名称 | 说明 |
|--------|---------|------|
| `ME` | 机械件 | 机械加工件、机加件 |
| `EL` | 电气件 | 电气元件、电子器件 |
| `PN` | 气动件 | 气动元件、气缸、阀类 |
| `ST` | 标准件 | 标准件、通用件 |
| `OT` | 其他 | 其他类别、未分类 |
| `TR` | 贸易件 | 贸易件（扩展支持）|

**示例**：
- `MAT-ME-00001` - 机械件第1个
- `MAT-EL-00015` - 电气件第15个
- `MAT-PN-00123` - 气动件第123个
- `MAT-ST-00001` - 标准件第1个

**容量**：每个类别支持 99,999 个物料

**生成方式**：
```python
from app.utils.number_generator import generate_material_code

# 根据分类编码生成（从分类编码中提取类别码）
material_code = generate_material_code(db, "ME-01-01")  # 生成 MAT-ME-00001

# 无类别时使用OT
material_code = generate_material_code(db, None)  # 生成 MAT-OT-00001
```

**API使用**：
创建物料时，如果不提供 `material_code`，系统会根据 `category_id` 自动生成：
```python
POST /api/v1/materials/
{
    "material_name": "测试物料",
    "category_id": 1,  # 物料分类ID，系统会从分类编码中提取类别码
    # material_code 可选，不提供则自动生成
}
```

### 2.4 设备编号 (Machine Code) - 保持不变

**格式**：`PJxxx-PNxxx`

**规则**：
- 项目编码 + `-PN` + 3位序号
- 与项目编码关联

**示例**：
- `PJ250708001-PN001` - 项目PJ250708001的第1台设备
- `PJ250708001-PN002` - 项目PJ250708001的第2台设备

**说明**：已实现，无需修改

### 2.5 项目编号 (Project Code) - 保持不变

**格式**：`PJyymmddxxx`

**规则**：
- `PJ` + 年月日（6位） + 3位序号
- 按日期分组，每天从001开始

**示例**：
- `PJ250708001` - 2025年7月8日第1个项目
- `PJ250708002` - 2025年7月8日第2个项目

**说明**：已实现，无需修改

## 三、技术实现

### 3.1 编码配置模块

编码规则定义在 `app/utils/code_config.py`：

```python
# 编码前缀
CODE_PREFIX = {
    'EMPLOYEE': 'EMP',
    'CUSTOMER': 'CUS',
    'MATERIAL': 'MAT',
    'PROJECT': 'PJ',
    'MACHINE': 'PN',
}

# 序号长度
SEQ_LENGTH = {
    'EMPLOYEE': 5,
    'CUSTOMER': 7,
    'MATERIAL': 5,
    'PROJECT': 3,
    'MACHINE': 3,
}
```

### 3.2 编号生成工具

编码生成函数在 `app/utils/number_generator.py`：

- `generate_employee_code(db)` - 生成员工编号
- `generate_customer_code(db)` - 生成客户编号
- `generate_material_code(db, category_code)` - 生成物料编号

### 3.3 API集成

#### 员工编码

在创建用户时自动生成员工编码：
```python
# app/api/v1/endpoints/users.py
from app.utils.number_generator import generate_employee_code

employee_code = generate_employee_code(db)
```

#### 客户编码

在创建客户时，如果未提供编码则自动生成：
```python
# app/api/v1/endpoints/customers.py
if not customer_data.get('customer_code'):
    customer_data['customer_code'] = generate_customer_code(db)
```

#### 物料编码

在创建物料时，如果未提供编码则根据类别自动生成：
```python
# app/api/v1/endpoints/materials.py
if not material_data.get('material_code'):
    category_code = category.category_code if category else None
    material_data['material_code'] = generate_material_code(db, category_code)
```

## 四、编码识别

通过前缀快速识别编码类型：

- `EMP-` → 员工
- `CUS-` → 客户
- `MAT-` → 物料
- `PJ` → 项目（无分隔符，但以PJ开头）
- `-PN` → 设备/机台（在项目编码后）

## 五、数据迁移

### 5.1 迁移脚本

迁移脚本位于：
- `migrations/20260127_master_data_code_system_sqlite.sql`
- `migrations/20260127_master_data_code_system_mysql.sql`

### 5.2 迁移策略

- **新数据**：自动使用新格式编码
- **旧数据**：可以保持原样，或使用迁移脚本转换（可选）

### 5.3 唯一性验证

确保所有编码字段的唯一性约束：
- `employees.employee_code` - UNIQUE
- `customers.customer_code` - UNIQUE
- `materials.material_code` - UNIQUE

## 六、扩展性

### 6.1 新增编码类型

如需新增编码类型，只需在 `code_config.py` 中添加配置：

```python
CODE_PREFIX['NEW_TYPE'] = 'NEW'
SEQ_LENGTH['NEW_TYPE'] = 6
```

### 6.2 调整序号长度

如需调整序号长度，修改 `SEQ_LENGTH` 配置即可。

### 6.3 扩展物料类别

在 `MATERIAL_CATEGORY_CODES` 中添加新类别：

```python
MATERIAL_CATEGORY_CODES = {
    'ME': '机械件',
    'EL': '电气件',
    # ... 现有类别
    'NEW': '新类别',  # 新增
}
```

## 七、测试

单元测试位于 `tests/unit/test_code_generator.py`，覆盖：

- 编码生成功能
- 编码唯一性
- 编码格式验证
- 类别码提取和验证

运行测试：
```bash
pytest tests/unit/test_code_generator.py
```

## 八、使用示例

### 8.1 创建员工（自动生成编码）

```python
# 通过API创建用户，系统自动生成员工编码
POST /api/v1/users/
{
    "username": "zhangsan",
    "real_name": "张三",
    "password": "password123"
}
# 系统自动创建员工记录，编码为 EMP-00001
```

### 8.2 创建客户（自动生成编码）

```python
# 创建客户，不提供编码
POST /api/v1/customers/
{
    "customer_name": "测试客户公司"
}
# 系统自动生成编码 CUS-0000001
```

### 8.3 创建物料（自动生成编码）

```python
# 创建物料，不提供编码
POST /api/v1/materials/
{
    "material_name": "伺服电机",
    "category_id": 5  # 电气件分类
}
# 系统根据分类自动生成编码 MAT-EL-00001
```

## 九、常见问题

### Q1: 如何手动指定编码？

A: 在创建时提供 `code` 字段即可，系统会验证唯一性。

### Q2: 旧格式编码如何处理？

A: 旧格式编码可以保持原样，新创建的数据将使用新格式。如需统一，可使用迁移脚本转换。

### Q3: 物料编码的类别码如何确定？

A: 系统从物料分类的 `category_code` 字段中提取第一个部分作为类别码。例如 `ME-01-01` 提取为 `ME`。

### Q4: 编码生成是否线程安全？

A: 编码生成基于数据库查询，在事务中执行，保证唯一性。但建议在高并发场景下使用数据库锁或序列。

## 十、更新日志

- **2026-01-27**: 初始版本，实现员工、客户、物料编码体系

# 工单智能分配功能实现方案

> **创建日期**：2026-01-15  
> **功能目标**：实现工单自动匹配转办人、支持多项目关联、智能筛选相关人员

---

## 一、功能需求分析

### 1.1 核心需求

1. **自动匹配转办人**
   - 工单创建时，根据选择的项目自动获取项目成员列表
   - 自动筛选出与项目相关的人员供选择

2. **多项目关联**
   - 支持工单关联到多个项目（单选或多选）
   - 根据关联的项目自动合并相关人员列表

3. **人员选择**
   - 处理人员（必选，单选）
   - 抄送人员（可选，多选）

4. **智能筛选**
   - 根据关联的项目自动筛选相关人员
   - 去重处理（同一人员在多个项目中只显示一次）

---

## 二、数据模型设计

### 2.1 工单多项目关联表（新增）

```sql
-- 工单项目关联表（支持多对多）
CREATE TABLE service_ticket_projects (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    ticket_id INTEGER NOT NULL,
    project_id INTEGER NOT NULL,
    is_primary BOOLEAN DEFAULT FALSE,  -- 是否主项目
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (ticket_id) REFERENCES service_tickets(id) ON DELETE CASCADE,
    FOREIGN KEY (project_id) REFERENCES projects(id),
    UNIQUE(ticket_id, project_id)
);

CREATE INDEX idx_ticket_projects_ticket ON service_ticket_projects(ticket_id);
CREATE INDEX idx_ticket_projects_project ON service_ticket_projects(project_id);
```

### 2.2 工单抄送人员表（新增）

```sql
-- 工单抄送人员表
CREATE TABLE service_ticket_cc_users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    ticket_id INTEGER NOT NULL,
    user_id INTEGER NOT NULL,
    notified_at DATETIME,  -- 通知时间
    read_at DATETIME,      -- 阅读时间
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (ticket_id) REFERENCES service_tickets(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id),
    UNIQUE(ticket_id, user_id)
);

CREATE INDEX idx_ticket_cc_ticket ON service_ticket_cc_users(ticket_id);
CREATE INDEX idx_ticket_cc_user ON service_ticket_cc_users(user_id);
```

### 2.3 工单模型扩展（可选）

**方案A：保持现有结构，使用关联表**
- 保留 `project_id` 作为主项目（向后兼容）
- 使用 `service_ticket_projects` 表支持多项目关联

**方案B：修改现有结构**
- 移除 `project_id`，完全使用关联表
- 需要数据迁移

**推荐方案A**：保持向后兼容，同时支持多项目关联。

---

## 三、后端API设计

### 3.1 获取项目相关人员API（新增）

**端点**：`GET /api/v1/service-tickets/project-members`

**功能**：根据项目ID列表获取所有相关人员

**参数**：
```python
project_ids: List[int] = Query(..., description="项目ID列表")
include_roles: Optional[List[str]] = Query(None, description="包含的角色（可选）")
```

**返回**：
```json
{
  "members": [
    {
      "user_id": 1,
      "username": "zhangsan",
      "real_name": "张三",
      "role_code": "PM",
      "role_name": "项目经理",
      "projects": [1, 2],  // 该人员在哪些项目中
      "is_lead": false
    }
  ],
  "total": 10
}
```

**实现逻辑**：
```python
def get_project_members_for_ticket(
    db: Session,
    project_ids: List[int],
    include_roles: Optional[List[str]] = None
) -> List[Dict]:
    """
    获取项目相关人员（去重）
    """
    query = db.query(ProjectMember).filter(
        ProjectMember.project_id.in_(project_ids),
        ProjectMember.is_active == True
    )
    
    if include_roles:
        query = query.filter(ProjectMember.role_code.in_(include_roles))
    
    members = query.all()
    
    # 按用户ID去重，合并项目列表
    user_members = {}
    for member in members:
        user_id = member.user_id
        if user_id not in user_members:
            user_members[user_id] = {
                "user_id": user_id,
                "username": member.user.username,
                "real_name": member.user.real_name,
                "role_code": member.role_code,
                "role_name": member.role_type.role_name if member.role_type else member.role_code,
                "projects": [],
                "is_lead": member.is_lead
            }
        user_members[user_id]["projects"].append(member.project_id)
    
    return list(user_members.values())
```

### 3.2 工单创建API扩展

**修改**：`POST /api/v1/service-tickets`

**新增字段**：
```python
class ServiceTicketCreate(BaseModel):
    project_id: int  # 主项目（保持向后兼容）
    project_ids: Optional[List[int]] = None  # 关联项目列表（新增）
    customer_id: int
    problem_type: str
    problem_desc: str
    urgency: str
    reported_by: str
    reported_time: datetime
    assignee_id: Optional[int] = None  # 处理人（新增，创建时可直接分配）
    cc_user_ids: Optional[List[int]] = None  # 抄送人员（新增）
```

**处理逻辑**：
```python
# 1. 创建工单
ticket = ServiceTicket(...)
db.add(ticket)
db.commit()

# 2. 创建项目关联（如果提供了project_ids）
if project_ids:
    for project_id in project_ids:
        is_primary = (project_id == ticket.project_id)
        ticket_project = ServiceTicketProject(
            ticket_id=ticket.id,
            project_id=project_id,
            is_primary=is_primary
        )
        db.add(ticket_project)

# 3. 创建抄送人员（如果提供了cc_user_ids）
if cc_user_ids:
    for user_id in cc_user_ids:
        cc_user = ServiceTicketCcUser(
            ticket_id=ticket.id,
            user_id=user_id
        )
        db.add(cc_user)

# 4. 如果创建时指定了处理人，直接分配
if assignee_id:
    ticket.assigned_to_id = assignee_id
    ticket.status = "IN_PROGRESS"
    # ... 分配逻辑

db.commit()
```

### 3.3 工单分配API扩展

**修改**：`PUT /api/v1/service-tickets/{ticket_id}/assign`

**新增字段**：
```python
class ServiceTicketAssign(BaseModel):
    assignee_id: int  # 处理人
    cc_user_ids: Optional[List[int]] = None  # 抄送人员（新增）
    comment: Optional[str] = None
```

**处理逻辑**：
```python
# 1. 更新处理人
ticket.assigned_to_id = assign_in.assignee_id
ticket.status = "IN_PROGRESS"

# 2. 更新抄送人员
if assign_in.cc_user_ids:
    # 删除旧的抄送人员
    db.query(ServiceTicketCcUser).filter(
        ServiceTicketCcUser.ticket_id == ticket_id
    ).delete()
    
    # 添加新的抄送人员
    for user_id in assign_in.cc_user_ids:
        if user_id != assign_in.assignee_id:  # 处理人不作为抄送人
            cc_user = ServiceTicketCcUser(
                ticket_id=ticket_id,
                user_id=user_id,
                notified_at=datetime.now()
            )
            db.add(cc_user)
```

### 3.4 获取工单关联项目API（新增）

**端点**：`GET /api/v1/service-tickets/{ticket_id}/projects`

**返回**：
```json
{
  "primary_project": {
    "id": 1,
    "project_code": "PJ250115001",
    "project_name": "项目A"
  },
  "related_projects": [
    {
      "id": 2,
      "project_code": "PJ250115002",
      "project_name": "项目B"
    }
  ]
}
```

---

## 四、前端实现设计

### 4.1 工单创建表单增强

**新增字段**：
1. **关联项目**（多选）
   - 支持选择多个项目
   - 第一个选择的项目作为主项目
   - 显示项目名称和编码

2. **处理人员**（单选）
   - 根据选择的项目自动加载相关人员
   - 显示人员姓名、角色、所属项目
   - 支持搜索过滤

3. **抄送人员**（多选）
   - 从相同的人员列表中选择
   - 支持多选
   - 显示已选择的人员列表

### 4.2 交互流程

```
1. 用户选择项目（单选或多选）
   ↓
2. 前端调用API获取项目相关人员
   GET /api/v1/service-tickets/project-members?project_ids=[1,2,3]
   ↓
3. 显示人员列表（去重后）
   - 显示：姓名、角色、所属项目
   - 支持搜索和过滤
   ↓
4. 用户选择处理人员和抄送人员
   ↓
5. 提交创建工单
   POST /api/v1/service-tickets
   {
     project_id: 1,  // 主项目
     project_ids: [1, 2, 3],  // 所有关联项目
     assignee_id: 5,  // 处理人
     cc_user_ids: [6, 7]  // 抄送人员
   }
```

### 4.3 组件设计

**CreateTicketDialog组件结构**：
```jsx
<CreateTicketDialog>
  {/* 基本信息 */}
  <ProjectSelector 
    value={projectIds}
    onChange={handleProjectChange}
    multiple={true}  // 支持多选
  />
  
  {/* 自动加载相关人员 */}
  {projectIds.length > 0 && (
    <ProjectMembersSelector
      projectIds={projectIds}
      onMembersLoaded={setAvailableMembers}
    />
  )}
  
  {/* 处理人员选择 */}
  <AssigneeSelector
    members={availableMembers}
    value={assigneeId}
    onChange={setAssigneeId}
  />
  
  {/* 抄送人员选择 */}
  <CcUsersSelector
    members={availableMembers}
    value={ccUserIds}
    onChange={setCcUserIds}
    excludeUserId={assigneeId}  // 排除处理人
  />
</CreateTicketDialog>
```

---

## 五、实现步骤

### Phase 1: 数据模型扩展（1-2天）

1. **创建关联表**
   - `service_ticket_projects` 表
   - `service_ticket_cc_users` 表
   - 数据库迁移脚本

2. **创建ORM模型**
   - `ServiceTicketProject` 模型
   - `ServiceTicketCcUser` 模型
   - 添加关系定义

### Phase 2: 后端API实现（2-3天）

1. **新增API端点**
   - `GET /api/v1/service-tickets/project-members` - 获取项目相关人员
   - `GET /api/v1/service-tickets/{ticket_id}/projects` - 获取工单关联项目

2. **扩展现有API**
   - `POST /api/v1/service-tickets` - 支持多项目关联和抄送
   - `PUT /api/v1/service-tickets/{ticket_id}/assign` - 支持抄送人员

3. **Schema扩展**
   - `ServiceTicketCreate` 添加新字段
   - `ServiceTicketAssign` 添加抄送字段
   - 新增响应模型

### Phase 3: 前端实现（2-3天）

1. **工单创建表单增强**
   - 多项目选择组件
   - 人员选择组件（处理人+抄送人）
   - 自动加载项目成员

2. **工单分配对话框增强**
   - 支持选择抄送人员
   - 显示项目相关人员

3. **工单详情页增强**
   - 显示关联的所有项目
   - 显示抄送人员列表

### Phase 4: 测试和优化（1-2天）

1. **功能测试**
   - 多项目关联测试
   - 人员自动筛选测试
   - 抄送功能测试

2. **性能优化**
   - 人员列表去重优化
   - 批量查询优化

---

## 六、技术实现细节

### 6.1 获取项目相关人员服务

**文件**：`app/services/ticket_assignment_service.py`（新建）

```python
def get_project_members_for_ticket(
    db: Session,
    project_ids: List[int],
    include_roles: Optional[List[str]] = None,
    exclude_user_id: Optional[int] = None
) -> List[Dict[str, Any]]:
    """
    获取项目相关人员（去重）
    
    Args:
        project_ids: 项目ID列表
        include_roles: 包含的角色（可选）
        exclude_user_id: 排除的用户ID（如当前用户）
    
    Returns:
        去重后的人员列表，包含该人员在哪些项目中
    """
    from app.models.project import ProjectMember
    from app.models.user import User
    
    query = db.query(ProjectMember).filter(
        ProjectMember.project_id.in_(project_ids),
        ProjectMember.is_active == True
    )
    
    if include_roles:
        query = query.filter(ProjectMember.role_code.in_(include_roles))
    
    if exclude_user_id:
        query = query.filter(ProjectMember.user_id != exclude_user_id)
    
    members = query.all()
    
    # 按用户ID去重，合并项目列表
    user_members = {}
    for member in members:
        user_id = member.user_id
        if user_id not in user_members:
            user = member.user
            user_members[user_id] = {
                "user_id": user_id,
                "username": user.username,
                "real_name": user.real_name or user.username,
                "email": user.email,
                "phone": user.phone,
                "department": user.department,
                "position": user.position,
                "role_code": member.role_code,
                "role_name": member.role_type.role_name if member.role_type else member.role_code,
                "projects": [],
                "is_lead": member.is_lead,
                "allocation_pct": float(member.allocation_pct or 100)
            }
        user_members[user_id]["projects"].append({
            "project_id": member.project_id,
            "project_code": member.project.project_code if member.project else None,
            "project_name": member.project.project_name if member.project else None,
            "role_code": member.role_code,
            "is_lead": member.is_lead
        })
    
    # 按角色和姓名排序
    role_priority = {
        "PM": 1, "PMC": 2, "ME": 3, "EE": 4, 
        "SW": 5, "DEBUG": 6, "QA": 7, "SALES": 8
    }
    
    sorted_members = sorted(
        user_members.values(),
        key=lambda x: (
            role_priority.get(x["role_code"], 99),
            x["real_name"]
        )
    )
    
    return sorted_members
```

### 6.2 工单创建服务扩展

**文件**：`app/api/v1/endpoints/service.py`

```python
@router.post("/service-tickets", response_model=ServiceTicketResponse, status_code=status.HTTP_201_CREATED)
def create_service_ticket(
    *,
    db: Session = Depends(deps.get_db),
    ticket_in: ServiceTicketCreate,
    current_user: User = Depends(security.get_current_active_user),
) -> Any:
    """
    创建服务工单（支持多项目关联和直接分配）
    """
    # 验证主项目
    project = db.query(Project).filter(Project.id == ticket_in.project_id).first()
    if not project:
        raise HTTPException(status_code=404, detail=f"项目不存在 (ID: {ticket_in.project_id})")
    
    # 验证关联项目（如果提供了）
    if ticket_in.project_ids:
        for project_id in ticket_in.project_ids:
            if not db.query(Project).filter(Project.id == project_id).first():
                raise HTTPException(status_code=404, detail=f"关联项目不存在 (ID: {project_id})")
    
    # 验证处理人（如果创建时指定）
    if ticket_in.assignee_id:
        assignee = db.query(User).filter(User.id == ticket_in.assignee_id).first()
        if not assignee:
            raise HTTPException(status_code=404, detail="处理人不存在")
    
    # 验证抄送人员（如果提供了）
    if ticket_in.cc_user_ids:
        for user_id in ticket_in.cc_user_ids:
            if not db.query(User).filter(User.id == user_id).first():
                raise HTTPException(status_code=404, detail=f"抄送人员不存在 (ID: {user_id})")
    
    # 创建工单
    ticket = ServiceTicket(
        ticket_no=generate_ticket_no(db),
        project_id=ticket_in.project_id,  # 主项目
        customer_id=ticket_in.customer_id,
        problem_type=ticket_in.problem_type,
        problem_desc=ticket_in.problem_desc,
        urgency=ticket_in.urgency,
        reported_by=ticket_in.reported_by,
        reported_time=ticket_in.reported_time,
        status="PENDING" if not ticket_in.assignee_id else "IN_PROGRESS",  # 如果指定了处理人，直接变为处理中
        assigned_to_id=ticket_in.assignee_id,
        assigned_to_name=assignee.name if ticket_in.assignee_id and assignee else None,
        assigned_time=datetime.now() if ticket_in.assignee_id else None,
        response_time=datetime.now() if ticket_in.assignee_id else None,
        timeline=[{
            "type": "REPORTED",
            "timestamp": ticket_in.reported_time.isoformat(),
            "user": ticket_in.reported_by,
            "description": "客户报告问题",
        }],
    )
    
    if ticket_in.assignee_id:
        ticket.timeline.append({
            "type": "ASSIGNED",
            "timestamp": datetime.now().isoformat(),
            "user": current_user.real_name or current_user.username,
            "description": f"工单已分配给 {assignee.name or assignee.username}",
        })
    
    db.add(ticket)
    db.commit()
    db.refresh(ticket)
    
    # 创建项目关联
    all_project_ids = [ticket_in.project_id]
    if ticket_in.project_ids:
        all_project_ids.extend(ticket_in.project_ids)
        all_project_ids = list(set(all_project_ids))  # 去重
    
    for project_id in all_project_ids:
        is_primary = (project_id == ticket_in.project_id)
        ticket_project = ServiceTicketProject(
            ticket_id=ticket.id,
            project_id=project_id,
            is_primary=is_primary
        )
        db.add(ticket_project)
    
    # 创建抄送人员
    if ticket_in.cc_user_ids:
        for user_id in ticket_in.cc_user_ids:
            if user_id != ticket_in.assignee_id:  # 处理人不作为抄送人
                cc_user = ServiceTicketCcUser(
                    ticket_id=ticket.id,
                    user_id=user_id,
                    notified_at=datetime.now()
                )
                db.add(cc_user)
    
    db.commit()
    
    # 创建SLA监控
    try:
        from app.services.sla_service import match_sla_policy, create_sla_monitor
        policy = match_sla_policy(db, ticket.problem_type, ticket.urgency)
        if policy:
            create_sla_monitor(db, ticket, policy)
    except Exception as e:
        import logging
        logging.error(f"创建SLA监控记录失败: {e}")
    
    return ticket
```

---

## 七、前端组件实现

### 7.1 项目多选组件

```jsx
function ProjectMultiSelector({ value, onChange, projects }) {
  const [selectedProjects, setSelectedProjects] = useState(value || []);
  
  const handleToggle = (projectId) => {
    const newSelected = selectedProjects.includes(projectId)
      ? selectedProjects.filter(id => id !== projectId)
      : [...selectedProjects, projectId];
    setSelectedProjects(newSelected);
    onChange(newSelected);
  };
  
  return (
    <div className="space-y-2">
      <label className="text-sm text-slate-400">关联项目 *</label>
      <div className="border border-slate-700 rounded-lg p-3 max-h-48 overflow-y-auto">
        {projects.map(project => (
          <div key={project.id} className="flex items-center gap-2 py-2">
            <input
              type="checkbox"
              checked={selectedProjects.includes(project.id)}
              onChange={() => handleToggle(project.id)}
              className="w-4 h-4"
            />
            <span className="text-white">
              {project.project_name} ({project.project_code})
            </span>
            {selectedProjects[0] === project.id && (
              <Badge className="bg-blue-500/20 text-blue-400">主项目</Badge>
            )}
          </div>
        ))}
      </div>
      {selectedProjects.length > 0 && (
        <div className="text-xs text-slate-500">
          已选择 {selectedProjects.length} 个项目
        </div>
      )}
    </div>
  );
}
```

### 7.2 人员选择组件

```jsx
function MemberSelector({ 
  members, 
  value, 
  onChange, 
  label, 
  multiple = false,
  excludeUserIds = [] 
}) {
  const filteredMembers = members.filter(
    m => !excludeUserIds.includes(m.user_id)
  );
  
  return (
    <div className="space-y-2">
      <label className="text-sm text-slate-400">{label}</label>
      <Select
        value={value?.toString()}
        onValueChange={(val) => onChange(multiple ? [] : parseInt(val))}
      >
        <SelectTrigger>
          <SelectValue placeholder={`选择${label}`} />
        </SelectTrigger>
        <SelectContent>
          {filteredMembers.map(member => (
            <SelectItem key={member.user_id} value={member.user_id.toString()}>
              <div className="flex items-center justify-between">
                <span>{member.real_name}</span>
                <span className="text-xs text-slate-500 ml-2">
                  {member.role_name}
                </span>
              </div>
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
}
```

### 7.3 工单创建表单完整实现

```jsx
function CreateTicketDialog({ onClose, onSubmit }) {
  const [formData, setFormData] = useState({
    project_id: "",
    project_ids: [],
    customer_id: "",
    problem_type: "",
    problem_desc: "",
    urgency: "MEDIUM",
    assignee_id: null,
    cc_user_ids: [],
  });
  
  const [projects, setProjects] = useState([]);
  const [members, setMembers] = useState([]);
  const [loadingMembers, setLoadingMembers] = useState(false);
  
  // 加载项目列表
  useEffect(() => {
    loadProjects();
  }, []);
  
  // 当项目选择变化时，加载相关人员
  useEffect(() => {
    if (formData.project_ids.length > 0) {
      loadProjectMembers(formData.project_ids);
    } else {
      setMembers([]);
    }
  }, [formData.project_ids]);
  
  const loadProjects = async () => {
    try {
      const res = await projectApi.list({ page_size: 1000 });
      setProjects(res.data?.items || res.data || []);
    } catch (err) {
      console.error("Failed to load projects:", err);
    }
  };
  
  const loadProjectMembers = async (projectIds) => {
    try {
      setLoadingMembers(true);
      const res = await serviceApi.getProjectMembers({
        project_ids: projectIds.join(",")
      });
      setMembers(res.data?.members || res.data || []);
    } catch (err) {
      console.error("Failed to load members:", err);
      setMembers([]);
    } finally {
      setLoadingMembers(false);
    }
  };
  
  const handleProjectChange = (projectIds) => {
    const primaryProjectId = projectIds[0] || "";
    setFormData({
      ...formData,
      project_id: primaryProjectId,
      project_ids: projectIds,
      assignee_id: null,  // 清空已选的处理人
      cc_user_ids: [],    // 清空已选的抄送人
    });
  };
  
  return (
    <Dialog open={true} onOpenChange={onClose}>
      <DialogContent className="max-w-3xl">
        <DialogHeader>
          <DialogTitle>创建服务工单</DialogTitle>
        </DialogHeader>
        <DialogBody>
          <div className="space-y-4">
            {/* 项目选择（多选） */}
            <ProjectMultiSelector
              value={formData.project_ids}
              onChange={handleProjectChange}
              projects={projects}
            />
            
            {/* 其他基本信息 */}
            {/* ... */}
            
            {/* 人员选择区域 */}
            {formData.project_ids.length > 0 && (
              <div className="space-y-4 p-4 bg-slate-800/30 rounded-lg">
                <div className="text-sm font-semibold text-white mb-2">
                  人员分配
                </div>
                
                {/* 处理人员 */}
                <MemberSelector
                  members={members}
                  value={formData.assignee_id}
                  onChange={(id) => setFormData({...formData, assignee_id: id})}
                  label="处理人员"
                  multiple={false}
                  excludeUserIds={formData.cc_user_ids}
                />
                
                {/* 抄送人员 */}
                <MemberMultiSelector
                  members={members}
                  value={formData.cc_user_ids}
                  onChange={(ids) => setFormData({...formData, cc_user_ids: ids})}
                  label="抄送人员（可选）"
                  excludeUserIds={formData.assignee_id ? [formData.assignee_id] : []}
                />
                
                {loadingMembers && (
                  <div className="text-sm text-slate-400">加载相关人员...</div>
                )}
                {!loadingMembers && members.length === 0 && (
                  <div className="text-sm text-slate-400">
                    所选项目暂无相关人员
                  </div>
                )}
              </div>
            )}
          </div>
        </DialogBody>
        <DialogFooter>
          <Button onClick={onClose}>取消</Button>
          <Button onClick={() => onSubmit(formData)}>创建工单</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

---

## 八、实现可行性分析

### 8.1 技术可行性 ✅

1. **数据模型**：✅ 完全可行
   - 使用关联表实现多对多关系
   - 不影响现有数据结构

2. **后端API**：✅ 完全可行
   - 可以基于现有的项目成员API扩展
   - 逻辑清晰，实现简单

3. **前端实现**：✅ 完全可行
   - 使用现有的Select组件
   - 交互逻辑简单明了

### 8.2 业务可行性 ✅

1. **自动匹配转办人**：✅ 完全可行
   - 项目成员数据已存在
   - 可以根据项目自动筛选

2. **多项目关联**：✅ 完全可行
   - 业务场景合理（一个问题可能涉及多个项目）
   - 数据模型支持

3. **人员选择**：✅ 完全可行
   - 处理人员和抄送人员的区分清晰
   - 符合实际业务需求

### 8.3 性能考虑

1. **人员列表去重**：在服务端完成，性能良好
2. **批量查询**：使用 `IN` 查询，性能可接受
3. **前端加载**：按需加载，不影响初始页面性能

---

## 九、实施建议

### 9.1 分阶段实施

**Phase 1（立即实施）**：基础功能
- 单项目自动匹配转办人
- 处理人员选择
- 抄送人员选择

**Phase 2（后续优化）**：多项目关联
- 支持多项目关联
- 多项目人员合并

### 9.2 向后兼容

- 保留 `project_id` 字段作为主项目
- 旧工单可以正常使用
- 新功能不影响现有功能

---

## 十、总结

### 10.1 功能完整性

✅ **可以实现**：
1. 工单创建时自动获取项目相关人员
2. 支持多项目关联（单选或多选）
3. 根据关联项目自动筛选相关人员
4. 支持选择处理人员和抄送人员
5. 人员列表自动去重

### 10.2 实现难度

- **数据模型**：中等（需要创建关联表）
- **后端API**：简单（基于现有API扩展）
- **前端实现**：简单（使用现有组件）

### 10.3 预计工作量

- **数据模型和迁移**：1-2天
- **后端API实现**：2-3天
- **前端实现**：2-3天
- **测试和优化**：1-2天

**总计**：6-10天

---

**文档版本**：v1.0  
**创建日期**：2026-01-15  
**最后更新**：2026-01-15

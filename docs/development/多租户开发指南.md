# 多租户开发指南 (Multi-Tenant Development Guide)

## 目录

- [1. 快速开始](#1-快速开始)
- [2. API开发最佳实践](#2-api开发最佳实践)
- [3. 租户隔离开发规范](#3-租户隔离开发规范)
- [4. 常见错误和解决方案](#4-常见错误和解决方案)
- [5. 代码审查清单](#5-代码审查清单)
- [6. 测试指南](#6-测试指南)

---

## 1. 快速开始

### 1.1 开发环境准备

```bash
# 克隆项目
git clone https://github.com/yourorg/non-standard-automation-pms.git
cd non-standard-automation-pms

# 创建虚拟环境
python3 -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# 安装依赖
pip install -r requirements.txt
pip install -r requirements-dev.txt  # 开发依赖

# 配置环境变量
cp .env.example .env
# 编辑 .env 文件，设置数据库连接等

# 初始化数据库
alembic upgrade head

# 创建默认租户
python scripts/create_default_tenant.py

# 创建超级管理员
python scripts/create_superuser.py

# 启动开发服务器
uvicorn app.main:app --reload
```

### 1.2 第一个多租户API

创建一个简单的租户感知API：

```python
# app/api/v1/endpoints/products.py

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.core.database import get_db
from app.core.auth import get_current_active_user
from app.models.user import User
from app.models.product import Product
from app.schemas.product import ProductCreate, ProductResponse

router = APIRouter(prefix="/products", tags=["products"])

@router.get("/", response_model=List[ProductResponse])
async def list_products(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """
    获取产品列表
    
    ✅ TenantQuery 会自动添加 WHERE tenant_id = current_user.tenant_id
    """
    products = db.query(Product).offset(skip).limit(limit).all()
    return products


@router.get("/{product_id}", response_model=ProductResponse)
async def get_product(
    product_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """
    获取单个产品
    
    ✅ 自动过滤 + 显式检查（防御性编程）
    """
    product = db.query(Product).filter(Product.id == product_id).first()
    
    if not product:
        raise HTTPException(status_code=404, detail="产品不存在")
    
    # 可选：显式检查租户权限（防御性编程）
    from app.core.permissions.tenant_access import require_tenant_access
    require_tenant_access(current_user, product.tenant_id)
    
    return product


@router.post("/", response_model=ProductResponse, status_code=201)
async def create_product(
    product_data: ProductCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """
    创建产品
    
    ✅ 自动设置 tenant_id 为当前用户的租户
    """
    product = Product(
        **product_data.dict(),
        tenant_id=current_user.tenant_id  # 强制使用当前用户的租户ID
    )
    
    db.add(product)
    db.commit()
    db.refresh(product)
    
    return product
```

**关键点**：
- ✅ 查询自动过滤：`TenantQuery` 自动添加 `tenant_id` 条件
- ✅ 创建自动设置：使用 `current_user.tenant_id`
- ✅ 防御性检查：使用 `require_tenant_access()` 显式验证

---

## 2. API开发最佳实践

### 2.1 列表查询 (List)

#### ✅ 推荐做法

```python
@router.get("/projects")
async def list_projects(
    status: Optional[str] = None,
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """获取项目列表 - 推荐写法"""
    
    # 基础查询（TenantQuery自动添加 tenant_id 过滤）
    query = db.query(Project)
    
    # 业务过滤条件
    if status:
        query = query.filter(Project.status == status)
    
    # 分页
    projects = query.offset(skip).limit(limit).all()
    
    return projects
```

**生成的SQL**:
```sql
SELECT * FROM projects 
WHERE tenant_id = 1       -- ✅ 自动添加
  AND status = 'active'   -- 业务条件
LIMIT 100 OFFSET 0;
```

#### ❌ 错误做法

```python
# ❌ 错误1: 手动添加 tenant_id（不必要）
query = db.query(Project).filter(Project.tenant_id == current_user.tenant_id)

# ❌ 错误2: 使用原始SQL（绕过TenantQuery）
projects = db.execute(text("SELECT * FROM projects")).fetchall()

# ❌ 错误3: 禁用自动过滤（除非确实需要）
projects = db.query(Project).skip_tenant_filter().all()
```

### 2.2 单个资源查询 (Get)

#### ✅ 推荐做法（防御性编程）

```python
@router.get("/projects/{project_id}")
async def get_project(
    project_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """获取单个项目 - 推荐写法"""
    
    # 查询（自动过滤）
    project = db.query(Project).filter(Project.id == project_id).first()
    
    # 检查存在性
    if not project:
        raise HTTPException(status_code=404, detail="项目不存在或无权访问")
    
    # 可选：显式验证租户权限（双重保障）
    if project.tenant_id != current_user.tenant_id and not is_superuser(current_user):
        raise HTTPException(status_code=403, detail="无权访问其他租户的资源")
    
    return project
```

**为什么要双重检查？**
- 第一层：TenantQuery 自动过滤（框架保障）
- 第二层：显式检查（防御性编程，防止框架失效）

#### 简化写法（信任框架）

```python
@router.get("/projects/{project_id}")
async def get_project(
    project_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """简化写法 - 完全信任TenantQuery"""
    
    project = db.query(Project).filter(Project.id == project_id).first()
    
    if not project:
        raise HTTPException(404, "项目不存在")
    
    return project
```

### 2.3 创建资源 (Create)

#### ✅ 推荐做法

```python
@router.post("/projects", status_code=201)
async def create_project(
    data: ProjectCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """创建项目 - 推荐写法"""
    
    # ✅ 强制使用当前用户的 tenant_id
    project = Project(
        **data.dict(),
        tenant_id=current_user.tenant_id,  # 必须
        created_by=current_user.id         # 可选：记录创建人
    )
    
    db.add(project)
    db.commit()
    db.refresh(project)
    
    return project
```

#### ❌ 错误做法

```python
# ❌ 错误1: 允许客户端指定 tenant_id（安全漏洞）
@router.post("/projects")
async def create_project(data: ProjectCreate, ...):
    project = Project(**data.dict())  # data 包含 tenant_id
    # ⚠️ 用户可以伪造 tenant_id，访问其他租户

# ❌ 错误2: 不设置 tenant_id（会导致 NULL）
project = Project(name=data.name, status=data.status)
# tenant_id 为 NULL，无法关联到租户
```

#### Pydantic Schema 设计

```python
# schemas/project.py

from pydantic import BaseModel
from typing import Optional

class ProjectCreate(BaseModel):
    """创建项目 Schema"""
    name: str
    description: Optional[str] = None
    status: str = "planning"
    
    # ❌ 不要包含 tenant_id（防止客户端伪造）
    # tenant_id: int  # 错误

class ProjectResponse(BaseModel):
    """项目响应 Schema"""
    id: int
    name: str
    description: Optional[str]
    status: str
    tenant_id: int  # ✅ 响应可以包含（只读）
    created_at: datetime
    
    class Config:
        from_attributes = True
```

### 2.4 更新资源 (Update)

#### ✅ 推荐做法

```python
@router.put("/projects/{project_id}")
async def update_project(
    project_id: int,
    data: ProjectUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """更新项目 - 推荐写法"""
    
    # 1. 查询（自动过滤）
    project = db.query(Project).filter(Project.id == project_id).first()
    if not project:
        raise HTTPException(404, "项目不存在或无权访问")
    
    # 2. 权限检查（可选）
    require_tenant_access(current_user, project.tenant_id)
    
    # 3. 更新字段
    for key, value in data.dict(exclude_unset=True).items():
        # ❌ 禁止更新 tenant_id
        if key == "tenant_id":
            continue
        setattr(project, key, value)
    
    # 4. 记录更新人（可选）
    project.updated_by = current_user.id
    
    db.commit()
    db.refresh(project)
    
    return project
```

#### Pydantic Schema

```python
class ProjectUpdate(BaseModel):
    """更新项目 Schema"""
    name: Optional[str] = None
    description: Optional[str] = None
    status: Optional[str] = None
    
    # ❌ 不允许更新 tenant_id
    # tenant_id: int  # 错误
```

### 2.5 删除资源 (Delete)

#### ✅ 推荐做法（软删除）

```python
@router.delete("/projects/{project_id}", status_code=204)
async def delete_project(
    project_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """删除项目 - 推荐写法（软删除）"""
    
    project = db.query(Project).filter(Project.id == project_id).first()
    if not project:
        raise HTTPException(404, "项目不存在或无权访问")
    
    # 权限检查
    require_tenant_access(current_user, project.tenant_id)
    
    # 软删除
    project.is_deleted = True
    project.deleted_at = datetime.utcnow()
    project.deleted_by = current_user.id
    
    db.commit()
    
    return None  # 204 No Content
```

#### 硬删除（谨慎使用）

```python
@router.delete("/projects/{project_id}/hard")
async def hard_delete_project(
    project_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_superuser)  # 仅超级管理员
):
    """硬删除项目 - 仅超级管理员"""
    
    project = db.query(Project).filter(Project.id == project_id).first()
    if not project:
        raise HTTPException(404, "项目不存在")
    
    # 记录审计日志
    audit_log.warning(
        f"Hard delete: project_id={project_id}, "
        f"tenant_id={project.tenant_id}, "
        f"admin_id={current_user.id}"
    )
    
    db.delete(project)
    db.commit()
    
    return None
```

### 2.6 关联查询 (Join)

#### ✅ 推荐做法

```python
@router.get("/projects/{project_id}/tasks")
async def list_project_tasks(
    project_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """获取项目的任务列表 - 推荐写法"""
    
    # 1. 验证项目存在且有权限
    project = db.query(Project).filter(Project.id == project_id).first()
    if not project:
        raise HTTPException(404, "项目不存在")
    
    # 2. 查询任务（自动过滤）
    tasks = db.query(Task).filter(Task.project_id == project_id).all()
    
    # ✅ TenantQuery 会自动为 Task 添加 tenant_id 过滤
    # 等价于: WHERE task.tenant_id = current_user.tenant_id AND project_id = ?
    
    return tasks
```

#### 使用 JOIN

```python
@router.get("/tasks")
async def list_tasks_with_project(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """获取任务列表（包含项目信息）"""
    
    # JOIN 查询
    results = (
        db.query(Task, Project)
        .join(Project, Task.project_id == Project.id)
        .all()
    )
    
    # ✅ TenantQuery 会为 Task 和 Project 都添加 tenant_id 过滤
    # 生成 SQL:
    # SELECT * FROM tasks 
    # JOIN projects ON tasks.project_id = projects.id
    # WHERE tasks.tenant_id = 1 AND projects.tenant_id = 1
    
    return [
        {
            "task": task,
            "project": project
        }
        for task, project in results
    ]
```

#### 预加载（eager loading）

```python
from sqlalchemy.orm import joinedload

@router.get("/projects")
async def list_projects_with_tasks(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """获取项目列表（预加载任务）- 避免 N+1 查询"""
    
    projects = (
        db.query(Project)
        .options(joinedload(Project.tasks))  # 预加载任务
        .all()
    )
    
    # ✅ 一次查询获取所有数据，租户过滤自动应用
    
    return projects
```

---

## 3. 租户隔离开发规范

### 3.1 模型设计规范

#### 业务模型（必须包含 tenant_id）

```python
# app/models/product.py

from sqlalchemy import Column, Integer, String, ForeignKey, Index
from sqlalchemy.orm import relationship
from app.models.base import Base, TimestampMixin

class Product(Base, TimestampMixin):
    """产品模型 - 标准业务模型"""
    
    __tablename__ = "products"
    
    # ✅ 必须包含的配置
    __table_args__ = (
        Index("idx_products_tenant", "tenant_id"),                    # 单列索引
        Index("idx_products_tenant_category", "tenant_id", "category"), # 复合索引
        {"extend_existing": True}  # 支持模型重载
    )
    
    # 主键
    id = Column(Integer, primary_key=True, autoincrement=True)
    
    # ✅ 租户ID（核心字段）
    tenant_id = Column(
        Integer,
        ForeignKey("tenants.id", ondelete="RESTRICT"),
        nullable=False,  # 生产环境必须设置
        index=True,      # 自动创建索引
        comment="租户ID（多租户隔离）"
    )
    
    # 业务字段
    name = Column(String(200), nullable=False, comment="产品名称")
    category = Column(String(50), comment="产品分类")
    price = Column(Decimal(10, 2), comment="价格")
    
    # 关系
    tenant = relationship("Tenant", back_populates="products")
    
    def __repr__(self):
        return f"<Product {self.name} (tenant_id={self.tenant_id})>"
```

#### 系统模型（不包含 tenant_id）

```python
# app/models/system_config.py

class SystemConfig(Base, TimestampMixin):
    """系统配置 - 系统级模型（不隔离）"""
    
    __tablename__ = "system_configs"
    
    id = Column(Integer, primary_key=True)
    config_key = Column(String(100), unique=True, nullable=False)
    config_value = Column(Text)
    config_type = Column(String(20))  # text, json, boolean
    
    # ❌ 注意：没有 tenant_id 字段
    # 所有租户共享这些配置
```

**何时使用系统模型？**
- ✅ 系统级配置（所有租户共享）
- ✅ 代码表（国家、省份、行业等）
- ✅ 审计日志（记录所有租户的操作）
- ❌ 业务数据（必须隔离）

### 3.2 数据库迁移规范

#### 创建迁移文件

```bash
# 自动生成迁移
alembic revision --autogenerate -m "add product model"

# 手动创建迁移
alembic revision -m "add custom index"
```

#### 迁移文件模板

```python
# migrations/versions/xxxx_add_product_model.py

from alembic import op
import sqlalchemy as sa

def upgrade():
    """升级数据库"""
    
    # 创建表
    op.create_table(
        'products',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('tenant_id', sa.Integer(), nullable=False),  # ✅ 必须
        sa.Column('name', sa.String(200), nullable=False),
        sa.Column('created_at', sa.DateTime(), nullable=False),
        
        # 主键
        sa.PrimaryKeyConstraint('id'),
        
        # 外键
        sa.ForeignKeyConstraint(
            ['tenant_id'], 
            ['tenants.id'],
            ondelete='RESTRICT'  # ✅ 防止误删租户
        )
    )
    
    # 创建索引
    op.create_index('idx_products_tenant', 'products', ['tenant_id'])
    op.create_index('idx_products_tenant_category', 'products', ['tenant_id', 'category'])


def downgrade():
    """降级数据库"""
    
    op.drop_index('idx_products_tenant_category', 'products')
    op.drop_index('idx_products_tenant', 'products')
    op.drop_table('products')
```

### 3.3 服务层规范

```python
# app/services/product_service.py

from typing import List, Optional
from sqlalchemy.orm import Session
from app.models.product import Product
from app.models.user import User
from app.schemas.product import ProductCreate, ProductUpdate

class ProductService:
    """产品服务"""
    
    @staticmethod
    def get_products(
        db: Session,
        current_user: User,
        skip: int = 0,
        limit: int = 100
    ) -> List[Product]:
        """获取产品列表"""
        
        # ✅ TenantQuery 自动过滤
        return db.query(Product).offset(skip).limit(limit).all()
    
    @staticmethod
    def get_product(
        db: Session,
        product_id: int,
        current_user: User
    ) -> Optional[Product]:
        """获取单个产品"""
        
        product = db.query(Product).filter(Product.id == product_id).first()
        
        # ✅ 验证租户权限
        if product and product.tenant_id != current_user.tenant_id:
            if not is_superuser(current_user):
                return None
        
        return product
    
    @staticmethod
    def create_product(
        db: Session,
        data: ProductCreate,
        current_user: User
    ) -> Product:
        """创建产品"""
        
        # ✅ 强制设置 tenant_id
        product = Product(
            **data.dict(),
            tenant_id=current_user.tenant_id,
            created_by=current_user.id
        )
        
        db.add(product)
        db.commit()
        db.refresh(product)
        
        return product
    
    @staticmethod
    def update_product(
        db: Session,
        product_id: int,
        data: ProductUpdate,
        current_user: User
    ) -> Optional[Product]:
        """更新产品"""
        
        product = ProductService.get_product(db, product_id, current_user)
        if not product:
            return None
        
        # 更新字段
        for key, value in data.dict(exclude_unset=True).items():
            if key != "tenant_id":  # ✅ 禁止更新 tenant_id
                setattr(product, key, value)
        
        product.updated_by = current_user.id
        
        db.commit()
        db.refresh(product)
        
        return product
    
    @staticmethod
    def delete_product(
        db: Session,
        product_id: int,
        current_user: User
    ) -> bool:
        """删除产品（软删除）"""
        
        product = ProductService.get_product(db, product_id, current_user)
        if not product:
            return False
        
        # 软删除
        product.is_deleted = True
        product.deleted_at = datetime.utcnow()
        product.deleted_by = current_user.id
        
        db.commit()
        
        return True
```

---

## 4. 常见错误和解决方案

### 4.1 错误1: 租户数据泄露

**错误代码**:
```python
# ❌ 使用原始SQL（绕过TenantQuery）
@router.get("/projects")
async def list_projects(db: Session = Depends(get_db)):
    results = db.execute(text("SELECT * FROM projects")).fetchall()
    return results
```

**问题**: 原始SQL绕过了 TenantQuery 的自动过滤，返回所有租户的数据。

**解决方案**:
```python
# ✅ 使用ORM查询
@router.get("/projects")
async def list_projects(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    projects = db.query(Project).all()  # 自动过滤
    return projects

# 或者，如果必须使用原始SQL，手动添加过滤
@router.get("/projects")
async def list_projects(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    results = db.execute(
        text("SELECT * FROM projects WHERE tenant_id = :tenant_id"),
        {"tenant_id": current_user.tenant_id}
    ).fetchall()
    return results
```

### 4.2 错误2: tenant_id 为 NULL

**错误代码**:
```python
# ❌ 创建时忘记设置 tenant_id
@router.post("/products")
async def create_product(data: ProductCreate, db: Session = Depends(get_db)):
    product = Product(**data.dict())  # tenant_id 为 NULL
    db.add(product)
    db.commit()
```

**问题**: 产品创建后 `tenant_id` 为 NULL，无法关联到任何租户。

**解决方案**:
```python
# ✅ 必须设置 tenant_id
@router.post("/products")
async def create_product(
    data: ProductCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    product = Product(
        **data.dict(),
        tenant_id=current_user.tenant_id  # ✅ 必须
    )
    db.add(product)
    db.commit()
```

### 4.3 错误3: 跨租户关联

**错误代码**:
```python
# ❌ 允许用户创建跨租户的关联
@router.post("/orders")
async def create_order(
    data: OrderCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    # 获取产品（可能是其他租户的）
    product = db.query(Product).filter(Product.id == data.product_id).first()
    
    order = Order(
        product_id=product.id,  # ❌ 可能跨租户
        tenant_id=current_user.tenant_id
    )
    db.add(order)
    db.commit()
```

**问题**: 用户可能关联到其他租户的产品。

**解决方案**:
```python
# ✅ 验证关联资源的租户
@router.post("/orders")
async def create_order(
    data: OrderCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    # 查询产品（自动过滤）
    product = db.query(Product).filter(Product.id == data.product_id).first()
    
    if not product:
        raise HTTPException(404, "产品不存在或无权访问")
    
    # ✅ product.tenant_id 自动等于 current_user.tenant_id（TenantQuery保障）
    
    order = Order(
        product_id=product.id,
        tenant_id=current_user.tenant_id
    )
    db.add(order)
    db.commit()
```

### 4.4 错误4: 超级管理员判断错误

**错误代码**:
```python
# ❌ 只判断 tenant_id
if user.tenant_id is None:
    # 认为是超级管理员（错误）
    pass
```

**问题**: `tenant_id=None` 但 `is_superuser=False` 是无效状态。

**解决方案**:
```python
# ✅ 使用统一的判断函数
from app.core.auth import is_superuser

if is_superuser(user):
    # 确保同时满足: is_superuser=True AND tenant_id=None
    pass
```

### 4.5 错误5: 缺少索引导致性能下降

**问题**: 添加 `tenant_id` 后查询变慢

**诊断**:
```sql
-- 检查查询计划
EXPLAIN SELECT * FROM projects WHERE tenant_id = 1 AND status = 'active';

-- 检查索引
SHOW INDEX FROM projects;
```

**解决方案**:
```sql
-- 添加复合索引
CREATE INDEX idx_projects_tenant_status ON projects(tenant_id, status);
```

---

## 5. 代码审查清单

### 5.1 模型审查清单

- [ ] 业务模型包含 `tenant_id` 字段
- [ ] `tenant_id` 设置 `nullable=False`（生产环境）
- [ ] 包含外键约束 `ForeignKey("tenants.id", ondelete="RESTRICT")`
- [ ] 包含单列索引 `Index("idx_xxx_tenant", "tenant_id")`
- [ ] 包含复合索引（如果有常用查询组合）
- [ ] 包含 `__table_args__` 配置 `extend_existing=True`

### 5.2 API审查清单

#### 查询 (GET)

- [ ] 使用 `db.query(Model)` 而不是原始SQL
- [ ] 依赖注入 `current_user: User = Depends(get_current_active_user)`
- [ ] 单个资源查询后检查 `if not resource: raise 404`
- [ ] 可选：显式验证 `require_tenant_access(current_user, resource.tenant_id)`

#### 创建 (POST)

- [ ] 强制设置 `tenant_id=current_user.tenant_id`
- [ ] Schema 不包含 `tenant_id` 字段（防止客户端伪造）
- [ ] 验证关联资源的租户（如果有）
- [ ] 记录创建人 `created_by=current_user.id`（可选）

#### 更新 (PUT/PATCH)

- [ ] 先查询资源（自动过滤）
- [ ] 检查资源存在性
- [ ] 禁止更新 `tenant_id` 字段
- [ ] 记录更新人 `updated_by=current_user.id`（可选）

#### 删除 (DELETE)

- [ ] 先查询资源（自动过滤）
- [ ] 检查资源存在性
- [ ] 使用软删除（推荐）
- [ ] 硬删除仅超级管理员（如果支持）
- [ ] 记录审计日志

### 5.3 安全审查清单

- [ ] 没有直接使用客户端提供的 `tenant_id`
- [ ] 没有绕过 TenantQuery（如使用原始SQL）
- [ ] 没有使用 `.skip_tenant_filter()` 除非确实需要
- [ ] 关联资源的租户验证
- [ ] 敏感操作记录审计日志
- [ ] 超级管理员操作使用 `get_current_active_superuser` 依赖

---

## 6. 测试指南

### 6.1 单元测试

```python
# tests/test_product_api.py

import pytest
from fastapi.testclient import TestClient
from app.main import app
from app.models.tenant import Tenant
from app.models.user import User
from app.models.product import Product

@pytest.fixture
def tenant_a(db):
    """租户A"""
    tenant = Tenant(tenant_code="tenant_a", tenant_name="租户A")
    db.add(tenant)
    db.commit()
    return tenant

@pytest.fixture
def tenant_b(db):
    """租户B"""
    tenant = Tenant(tenant_code="tenant_b", tenant_name="租户B")
    db.add(tenant)
    db.commit()
    return tenant

@pytest.fixture
def user_a(db, tenant_a):
    """租户A的用户"""
    user = User(
        username="user_a",
        email="user_a@tenant_a.com",
        tenant_id=tenant_a.id
    )
    db.add(user)
    db.commit()
    return user

@pytest.fixture
def product_a(db, tenant_a):
    """租户A的产品"""
    product = Product(
        name="Product A1",
        tenant_id=tenant_a.id
    )
    db.add(product)
    db.commit()
    return product

@pytest.fixture
def product_b(db, tenant_b):
    """租户B的产品"""
    product = Product(
        name="Product B1",
        tenant_id=tenant_b.id
    )
    db.add(product)
    db.commit()
    return product


class TestProductIsolation:
    """产品租户隔离测试"""
    
    def test_user_can_list_own_tenant_products(self, client, user_a, product_a):
        """用户可以查看本租户的产品列表"""
        token = get_token(client, user_a)
        
        response = client.get(
            "/api/v1/products",
            headers={"Authorization": f"Bearer {token}"}
        )
        
        assert response.status_code == 200
        products = response.json()
        assert len(products) == 1
        assert products[0]['id'] == product_a.id
    
    def test_user_cannot_access_other_tenant_product(self, client, user_a, product_b):
        """用户不能访问其他租户的产品"""
        token = get_token(client, user_a)
        
        response = client.get(
            f"/api/v1/products/{product_b.id}",
            headers={"Authorization": f"Bearer {token}"}
        )
        
        assert response.status_code == 404  # 或 403
    
    def test_create_product_auto_set_tenant(self, client, user_a):
        """创建产品自动设置租户ID"""
        token = get_token(client, user_a)
        
        response = client.post(
            "/api/v1/products",
            headers={"Authorization": f"Bearer {token}"},
            json={"name": "New Product"}
        )
        
        assert response.status_code == 201
        product = response.json()
        assert product['tenant_id'] == user_a.tenant_id
```

### 6.2 集成测试

```python
# tests/integration/test_tenant_isolation.py

class TestFullTenantIsolation:
    """完整的租户隔离测试"""
    
    def test_complete_isolation_workflow(self, client, db):
        """完整的隔离工作流测试"""
        
        # 1. 创建两个租户
        tenant_a = create_tenant(db, "tenant_a")
        tenant_b = create_tenant(db, "tenant_b")
        
        # 2. 创建用户
        user_a = create_user(db, tenant_a, "user_a")
        user_b = create_user(db, tenant_b, "user_b")
        
        # 3. 用户A创建产品
        token_a = get_token(client, user_a)
        response = client.post(
            "/api/v1/products",
            headers={"Authorization": f"Bearer {token_a}"},
            json={"name": "Product A"}
        )
        product_a_id = response.json()['id']
        
        # 4. 用户B创建产品
        token_b = get_token(client, user_b)
        response = client.post(
            "/api/v1/products",
            headers={"Authorization": f"Bearer {token_b}"},
            json={"name": "Product B"}
        )
        product_b_id = response.json()['id']
        
        # 5. 用户A只能看到自己的产品
        response = client.get(
            "/api/v1/products",
            headers={"Authorization": f"Bearer {token_a}"}
        )
        products = response.json()
        assert len(products) == 1
        assert products[0]['name'] == "Product A"
        
        # 6. 用户A不能访问用户B的产品
        response = client.get(
            f"/api/v1/products/{product_b_id}",
            headers={"Authorization": f"Bearer {token_a}"}
        )
        assert response.status_code == 404
        
        # 7. 用户B只能看到自己的产品
        response = client.get(
            "/api/v1/products",
            headers={"Authorization": f"Bearer {token_b}"}
        )
        products = response.json()
        assert len(products) == 1
        assert products[0]['name'] == "Product B"
```

### 6.3 性能测试

```python
# tests/performance/test_tenant_query_performance.py

import time
import pytest

class TestTenantQueryPerformance:
    """租户查询性能测试"""
    
    def test_query_performance_with_index(self, db, tenant_a):
        """测试带索引的查询性能"""
        
        # 创建大量数据
        for i in range(1000):
            product = Product(
                name=f"Product {i}",
                tenant_id=tenant_a.id
            )
            db.add(product)
        db.commit()
        
        # 测试查询时间
        start = time.time()
        products = db.query(Product).filter(
            Product.tenant_id == tenant_a.id
        ).all()
        elapsed = time.time() - start
        
        assert len(products) == 1000
        assert elapsed < 0.1  # 查询应在100ms内完成
    
    def test_tenant_filter_overhead(self, db, tenant_a):
        """测试租户过滤的性能开销"""
        
        # 创建测试数据
        for i in range(100):
            db.add(Product(name=f"Product {i}", tenant_id=tenant_a.id))
        db.commit()
        
        # 测试带过滤的查询
        start = time.time()
        products_filtered = db.query(Product).all()  # TenantQuery 自动过滤
        time_filtered = time.time() - start
        
        # 测试不带过滤的查询（超级管理员）
        start = time.time()
        products_all = db.query(Product).skip_tenant_filter().all()
        time_all = time.time() - start
        
        # 计算开销
        overhead = (time_filtered - time_all) / time_all * 100
        
        assert overhead < 10  # 开销应小于10%
```

---

## 附录

### A. 快速参考

#### 依赖注入

```python
# 获取当前用户
current_user: User = Depends(get_current_active_user)

# 获取超级管理员
current_user: User = Depends(get_current_active_superuser)

# 获取数据库Session
db: Session = Depends(get_db)
```

#### 权限检查

```python
# 检查租户访问权限
from app.core.permissions.tenant_access import require_tenant_access
require_tenant_access(current_user, resource.tenant_id)

# 检查是否超级管理员
from app.core.auth import is_superuser
if is_superuser(current_user):
    # 超级管理员操作
    pass
```

#### 跳过租户过滤

```python
# 方式1: 使用 skip_tenant_filter()
products = db.query(Product).skip_tenant_filter().all()

# 方式2: 在依赖中使用超级管理员
@router.get("/admin/all-products")
async def list_all_products(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_superuser)  # 超级管理员
):
    products = db.query(Product).all()  # 自动返回所有租户
    return products
```

### B. 常用命令

```bash
# 数据库迁移
alembic revision --autogenerate -m "add new model"
alembic upgrade head
alembic downgrade -1

# 运行测试
pytest tests/
pytest tests/test_product_api.py::TestProductIsolation::test_user_cannot_access_other_tenant_product -v

# 代码检查
ruff check .
mypy app/

# 启动开发服务器
uvicorn app.main:app --reload
```

---

**文档版本**: 1.0  
**最后更新**: 2026-02-16  
**维护团队**: Team 6 - 文档和部署  
**相关文档**:
- [架构设计](../architecture/多租户架构设计.md)
- [部署指南](../deployment/多租户部署指南.md)
- [运维指南](../operations/多租户运维指南.md)

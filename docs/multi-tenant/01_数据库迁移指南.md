# 数据库迁移指南 - 多租户架构升级

## 📋 概述

本指南用于将现有数据库升级至多租户架构，为 **473 张核心业务表** 添加 `tenant_id` 字段。

## 🎯 迁移目标

- 为所有业务表添加 `tenant_id` 字段
- 建立租户外键约束
- 创建必要的索引
- 保持现有数据完整性

## 📦 迁移文件

- **SQL 脚本**: `migrations/add_tenant_id_to_all_tables.sql`
- **大小**: 39 KB
- **影响表数**: 473 张

## 🛠️ 迁移方式

### 方式一：一次性全量迁移（测试环境推荐）

#### MySQL
```bash
# 备份数据库
mysqldump -u root -p your_database > backup_$(date +%Y%m%d).sql

# 执行迁移
mysql -u root -p your_database < migrations/add_tenant_id_to_all_tables.sql

# 验证
mysql -u root -p your_database -e "
SELECT table_name 
FROM information_schema.columns 
WHERE column_name = 'tenant_id' 
AND table_schema = 'your_database'
" | wc -l
# 应输出: 479（6张已有 + 473张新增）
```

#### PostgreSQL
```bash
# 备份数据库
pg_dump -U postgres your_database > backup_$(date +%Y%m%d).sql

# 执行迁移
psql -U postgres -d your_database -f migrations/add_tenant_id_to_all_tables.sql

# 验证
psql -U postgres -d your_database -c "
SELECT COUNT(*) 
FROM information_schema.columns 
WHERE column_name = 'tenant_id';
"
# 应输出: 479
```

---

### 方式二：分模块渐进式迁移（生产环境推荐）

**优势**:
- 降低锁表时间
- 便于回滚
- 降低风险

**步骤**:

#### 第一批：核心模块（已完成）
```sql
-- users, roles, api_keys 等核心表
-- 已在初期架构中完成
```

#### 第二批：项目管理模块（65张表）
```sql
-- 项目核心表
ALTER TABLE projects ADD COLUMN tenant_id INT NULL COMMENT '租户ID';
ALTER TABLE machines ADD COLUMN tenant_id INT NULL COMMENT '租户ID';
ALTER TABLE project_costs ADD COLUMN tenant_id INT NULL COMMENT '租户ID';
ALTER TABLE project_milestones ADD COLUMN tenant_id INT NULL COMMENT '租户ID';
-- ... 其他项目表

-- 添加外键
ALTER TABLE projects ADD CONSTRAINT fk_projects_tenant 
    FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT;
-- ... 其他外键

-- 添加索引
CREATE INDEX idx_projects_tenant ON projects(tenant_id);
CREATE INDEX idx_projects_tenant_status ON projects(tenant_id, status);
-- ... 其他索引

-- 验证
SELECT COUNT(*) FROM information_schema.columns 
WHERE table_schema = 'your_database' 
AND table_name LIKE 'project%' 
AND column_name = 'tenant_id';
-- 应输出: 65
```

#### 第三批：销售管理模块（54张表）
```sql
ALTER TABLE leads ADD COLUMN tenant_id INT NULL;
ALTER TABLE opportunities ADD COLUMN tenant_id INT NULL;
ALTER TABLE contracts ADD COLUMN tenant_id INT NULL;
-- ... 其他销售表
```

#### 第四批：生产管理模块（60张表）
```sql
ALTER TABLE work_orders ADD COLUMN tenant_id INT NULL;
ALTER TABLE production_plans ADD COLUMN tenant_id INT NULL;
ALTER TABLE quality_inspections ADD COLUMN tenant_id INT NULL;
-- ... 其他生产表
```

#### 第五批：其他业务模块（294张表）
```sql
-- 审批流程、工程变更、绩效管理等
-- 按模块逐步执行
```

---

### 方式三：使用 Alembic 迁移（代码管理推荐）

#### 1. 生成迁移文件
```bash
alembic revision -m "add_tenant_id_to_all_tables"
```

#### 2. 编写迁移脚本
```python
# migrations/versions/xxxx_add_tenant_id_to_all_tables.py
from alembic import op
import sqlalchemy as sa

# 待处理表清单
TABLES = [
    'projects', 'machines', 'work_orders', 'leads',
    # ... 完整的 473 张表
]

def upgrade():
    """添加 tenant_id 字段"""
    for table_name in TABLES:
        # 添加字段
        op.add_column(
            table_name,
            sa.Column('tenant_id', sa.Integer(), nullable=True, comment='租户ID')
        )
        
        # 添加外键
        op.create_foreign_key(
            f'fk_{table_name}_tenant',
            table_name, 'tenants',
            ['tenant_id'], ['id'],
            ondelete='RESTRICT'
        )
        
        # 添加索引
        op.create_index(
            f'idx_{table_name}_tenant',
            table_name,
            ['tenant_id']
        )

def downgrade():
    """回滚操作"""
    for table_name in TABLES:
        op.drop_constraint(f'fk_{table_name}_tenant', table_name)
        op.drop_index(f'idx_{table_name}_tenant', table_name)
        op.drop_column(table_name, 'tenant_id')
```

#### 3. 执行迁移
```bash
# 预览
alembic upgrade head --sql

# 执行
alembic upgrade head

# 回滚（如需要）
alembic downgrade -1
```

---

## 🔍 迁移验证

### 1. 字段完整性检查
```sql
-- 检查所有表是否包含 tenant_id
SELECT 
    table_name,
    column_name,
    data_type,
    is_nullable
FROM information_schema.columns
WHERE column_name = 'tenant_id'
AND table_schema = 'your_database'
ORDER BY table_name;

-- 预期结果: 479 行
```

### 2. 外键约束检查
```sql
SELECT 
    constraint_name,
    table_name,
    column_name,
    referenced_table_name,
    referenced_column_name
FROM information_schema.key_column_usage
WHERE referenced_table_name = 'tenants'
AND table_schema = 'your_database'
ORDER BY table_name;

-- 预期结果: 479 条外键
```

### 3. 索引完整性检查
```sql
SELECT 
    table_name,
    index_name,
    column_name
FROM information_schema.statistics
WHERE index_name LIKE 'idx_%_tenant%'
AND table_schema = 'your_database'
ORDER BY table_name;

-- 预期结果: 至少 473 条索引
```

### 4. 数据完整性检查
```sql
-- 检查是否有数据丢失
SELECT 
    table_name,
    COUNT(*) as row_count
FROM information_schema.tables t
JOIN (
    SELECT 'projects' as table_name UNION ALL
    SELECT 'work_orders' UNION ALL
    -- ... 其他关键表
) tables ON t.table_name = tables.table_name
WHERE t.table_schema = 'your_database';

-- 对比迁移前后的行数
```

---

## 📊 现有数据处理

### 方案一：设置默认租户
```sql
-- 创建默认租户（如果不存在）
INSERT INTO tenants (tenant_code, tenant_name, status, plan_type)
VALUES ('DEFAULT', '默认租户', 'ACTIVE', 'ENTERPRISE')
ON DUPLICATE KEY UPDATE tenant_code = tenant_code;

-- 获取默认租户ID
SET @default_tenant_id = (SELECT id FROM tenants WHERE tenant_code = 'DEFAULT');

-- 批量更新现有数据
UPDATE projects SET tenant_id = @default_tenant_id WHERE tenant_id IS NULL;
UPDATE work_orders SET tenant_id = @default_tenant_id WHERE tenant_id IS NULL;
UPDATE leads SET tenant_id = @default_tenant_id WHERE tenant_id IS NULL;
-- ... 其他表
```

### 方案二：基于用户归属自动分配
```sql
-- 根据创建人的租户ID自动分配
UPDATE projects p
JOIN users u ON p.created_by = u.id
SET p.tenant_id = u.tenant_id
WHERE p.tenant_id IS NULL;

UPDATE work_orders w
JOIN users u ON w.created_by = u.id
SET w.tenant_id = u.tenant_id
WHERE w.tenant_id IS NULL;

-- ... 其他表
```

### 方案三：根据业务规则分配
```sql
-- 例如：根据项目所属部门分配租户
UPDATE projects p
JOIN departments d ON p.dept_id = d.id
SET p.tenant_id = d.tenant_id
WHERE p.tenant_id IS NULL;
```

---

## ⚠️  注意事项

### 1. 性能影响
- **大表迁移**: 对于百万级数据的表，建议在低峰期执行
- **锁表时间**: `ADD COLUMN` 操作可能锁表，提前通知用户
- **分批处理**: 可以按 `id` 分批更新数据

```sql
-- 分批更新示例（每次 10000 条）
UPDATE projects SET tenant_id = 1 WHERE tenant_id IS NULL LIMIT 10000;
-- 重复执行直到 affected_rows = 0
```

### 2. 回滚准备
```sql
-- 迁移前记录表结构
mysqldump --no-data -u root -p your_database > schema_before.sql

-- 如需回滚
ALTER TABLE projects DROP FOREIGN KEY fk_projects_tenant;
ALTER TABLE projects DROP INDEX idx_projects_tenant;
ALTER TABLE projects DROP COLUMN tenant_id;
```

### 3. 监控指标
- 迁移执行时间
- 锁等待时间
- 磁盘空间使用
- 数据一致性

---

## 🎯 迁移时间估算

### 小型部署（< 10万条记录）
- **预计时间**: 15-30 分钟
- **策略**: 一次性全量迁移

### 中型部署（10万 - 100万条记录）
- **预计时间**: 1-3 小时
- **策略**: 分模块迁移，低峰期执行

### 大型部署（> 100万条记录）
- **预计时间**: 6-12 小时
- **策略**: 
  - 按模块分批执行
  - 使用在线 DDL（MySQL 5.7+）
  - 考虑使用 pt-online-schema-change

---

## ✅ 迁移检查清单

### 迁移前
- [ ] 完整备份数据库
- [ ] 确认维护窗口时间
- [ ] 通知相关用户
- [ ] 准备回滚脚本
- [ ] 检查磁盘空间

### 迁移中
- [ ] 执行迁移脚本
- [ ] 监控执行进度
- [ ] 记录执行日志
- [ ] 验证中间结果

### 迁移后
- [ ] 执行完整性检查
- [ ] 验证外键约束
- [ ] 检查索引效果
- [ ] 更新应用代码
- [ ] 功能测试
- [ ] 性能测试

---

## 📞 支持与反馈

如遇到问题，请检查：
1. 数据库版本兼容性
2. 执行日志中的错误信息
3. 磁盘空间是否充足
4. 权限是否足够

---

**文档版本**: v1.0  
**最后更新**: 2026-02-16  
**负责团队**: Agent Team 1

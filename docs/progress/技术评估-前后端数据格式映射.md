# 技术评估 - 前后端数据格式映射文档

**文档版本**: v1.0
**创建日期**: 2026-01-13
**维护人**: AI Assistant
**状态**: 第三阶段完成，准备进入第四阶段

---

## 1. 概述

本文档定义了线索技术评估功能的前后端数据格式映射关系，用于指导第四阶段的前端集成工作。

### 关键发现

- ✅ **后端服务层完整**：`TechnicalAssessmentService` 已实现所有评估逻辑（443行代码）
- ✅ **API 端点完整**：`/api/v1/sales/assessments/` 提供完整的评估接口（789行代码）
- ✅ **数据模型完整**：`TechnicalAssessment` 模型包含所有必要字段
- ⚠️ **前端未集成**：当前前端使用简化评估，数据存储在 `demand_summary` JSON 字段中

---

## 2. 评估维度映射

### 2.1 前端维度（当前实现）

前端使用 5 个评估维度，存储在 `demand_summary` JSON 中：

| 维度ID | 中文名称 | 权重 | 评分范围 |
|--------|---------|------|----------|
| `demand` | 需求明确度 | 25% | 1-5 |
| `budget` | 预算充足度 | 25% | 1-5 |
| `authority` | 决策权限 | 20% | 1-5 |
| `timeline` | 时间紧迫度 | 15% | 1-5 |
| `fit` | 方案匹配度 | 15% | 1-5 |

**前端评分计算逻辑**：
```javascript
totalScore = 0;
assessmentDimensions.forEach(dim => {
  totalScore += (score[dim.id] || 0) * dim.weight * 20; // 转换为100分制
});
totalScore = Math.round(totalScore);
```

**前端存储格式**（demand_summary 字段）：
```json
{
  "lead_name": "客户项目名称",
  "description": "需求描述文本",
  "estimated_amount": 500000,
  "assessment": {
    "score": 75,
    "grade": "hot",
    "assessmentDate": "2026-01-13",
    "assessedBy": "当前用户",
    "dimensions": {
      "demand": 4,
      "budget": 5,
      "authority": 3,
      "timeline": 4,
      "fit": 4
    }
  }
}
```

### 2.2 后端维度（TechnicalAssessmentService）

后端使用 5 个技术评估维度，每个维度 20 分：

| 维度ID | 中文名称 | 满分 | 说明 |
|--------|---------|------|------|
| `technology_score` | 技术可行性 | 20 | 技术难度、技术储备 |
| `business_score` | 商务条件 | 20 | 预算、决策链、采购流程 |
| `resource_score` | 资源匹配度 | 20 | 人力、物料、产能 |
| `delivery_score` | 交付可行性 | 20 | 交期、风险、验收条件 |
| `customer_score` | 客户维度 | 20 | 合作历史、信誉、付款能力 |

**后端存储格式**（TechnicalAssessment 表）：
```json
{
  "dimension_scores": {
    "technology_score": 18,
    "business_score": 16,
    "resource_score": 15,
    "delivery_score": 17,
    "customer_score": 14
  },
  "total_score": 80,
  "decision": "RECOMMEND",
  "veto_triggered": false,
  "veto_rules": [],
  "risks": [
    {
      "dimension": "resource_score",
      "level": "MEDIUM",
      "description": "资源紧张，需协调"
    }
  ],
  "similar_cases": [
    {
      "case_code": "FC2023001",
      "similarity": 0.85,
      "project_name": "某汽车客户FCT项目",
      "final_result": "失败",
      "lesson_learned": "交期过紧导致质量问题"
    }
  ],
  "conditions": ["需提前确认关键物料交期", "需安排资深工程师参与"],
  "ai_analysis": "AI 分析结果（可选）"
}
```

### 2.3 维度映射关系

| 前端维度 | 后端维度 | 映射说明 |
|---------|---------|---------|
| `demand` (需求明确度) | `technology_score` (技术可行性) | 需求明确度影响技术方案制定 |
| `budget` (预算充足度) | `business_score` (商务条件) | 预算是商务评估的核心要素 |
| `authority` (决策权限) | `business_score` (商务条件) | 决策权限影响商务流程 |
| `timeline` (时间紧迫度) | `delivery_score` (交付可行性) | 时间要求决定交付可行性 |
| `fit` (方案匹配度) | `resource_score` (资源匹配度) | 方案匹配度反映资源准备情况 |

**推荐映射策略**：

前端简化评估 → 后端完整评估的转换函数：

```python
def map_frontend_to_backend(frontend_scores: dict) -> dict:
    """
    将前端简化评估数据映射为后端 requirement_data 格式

    Args:
        frontend_scores: {
            "demand": 4,    # 1-5
            "budget": 5,
            "authority": 3,
            "timeline": 4,
            "fit": 4
        }

    Returns:
        requirement_data: {
            "demandClarity": 4,     # 需求明确度 (1-5)
            "budgetStatus": 5,      # 预算状态 (1-5)
            "decisionAuthority": 3, # 决策权限 (1-5)
            "timelineUrgency": 4,   # 时间紧迫度 (1-5)
            "solutionFit": 4        # 方案匹配度 (1-5)
        }
    """
    return {
        "demandClarity": frontend_scores.get("demand", 3),
        "budgetStatus": frontend_scores.get("budget", 3),
        "decisionAuthority": frontend_scores.get("authority", 3),
        "timelineUrgency": frontend_scores.get("timeline", 3),
        "solutionFit": frontend_scores.get("fit", 3),
    }
```

---

## 3. API 端点说明

### 3.1 申请技术评估

**端点**: `POST /api/v1/sales/leads/{lead_id}/assessments/apply`

**请求体**:
```json
{
  "evaluator_id": 5  // 可选，指定评估人ID
}
```

**响应**:
```json
{
  "message": "技术评估申请已提交",
  "data": {
    "assessment_id": 123
  }
}
```

**说明**：创建一个 PENDING 状态的评估记录，同时更新 Lead 的 `assessment_id` 字段。

### 3.2 执行技术评估

**端点**: `POST /api/v1/sales/assessments/{assessment_id}/evaluate`

**请求体**:
```json
{
  "requirement_data": {
    "demandClarity": 4,
    "budgetStatus": 5,
    "decisionAuthority": 3,
    "timelineUrgency": 4,
    "solutionFit": 4,
    "industry": "汽车电子",
    "productTypes": ["FCT", "ICT"],
    "taktTimeS": 30,
    "annualVolume": 100000,
    "deliveryMonths": 4
  },
  "enable_ai": false
}
```

**响应**: `TechnicalAssessmentResponse`（见下文）

**说明**：
- 调用 `TechnicalAssessmentService.evaluate()` 执行完整评估
- 计算 5 维度评分（每个维度 20 分）
- 检查一票否决规则
- 匹配相似失败案例
- 生成决策建议（RECOMMEND/CONDITIONAL/DEFER/NOT_RECOMMEND）
- 识别风险
- 生成条件要求（如果是 CONDITIONAL）
- 可选：调用 AI 分析

### 3.3 获取评估详情

**端点**: `GET /api/v1/sales/assessments/{assessment_id}`

**响应**:
```json
{
  "id": 123,
  "source_type": "LEAD",
  "source_id": 456,
  "evaluator_id": 5,
  "evaluator_name": "姚洪",
  "status": "COMPLETED",
  "total_score": 80,
  "dimension_scores": "{\"technology_score\": 18, ...}",
  "veto_triggered": false,
  "veto_rules": null,
  "decision": "RECOMMEND",
  "risks": "[{\"dimension\": \"resource_score\", ...}]",
  "similar_cases": "[{\"case_code\": \"FC2023001\", ...}]",
  "ai_analysis": null,
  "conditions": "[\"需提前确认关键物料交期\"]",
  "evaluated_at": "2026-01-13T10:30:00",
  "created_at": "2026-01-13T10:00:00",
  "updated_at": "2026-01-13T10:30:00"
}
```

### 3.4 获取线索的评估列表

**端点**: `GET /api/v1/sales/leads/{lead_id}/assessments`

**响应**: `List[TechnicalAssessmentResponse]`（按创建时间倒序）

---

## 4. 前端集成方案（第四阶段）

### 4.1 集成步骤

1. **修改 LeadAssessment.jsx 的 handleSubmitAssessment 函数**
   - 不再直接更新 `demand_summary` 字段
   - 调用后端评估 API：
     - 先调用 `/apply` 创建评估记录
     - 再调用 `/evaluate` 执行评估
   - 显示评估结果对话框

2. **创建 AssessmentResultDialog.jsx 组件**
   - 显示评估决策（推荐/有条件推荐/延期/不推荐）
   - 显示总分和各维度评分
   - 显示风险列表
   - 显示相似失败案例
   - 显示条件要求（如果是有条件推荐）
   - 显示一票否决原因（如果触发）

3. **更新 LeadAssessment.jsx 的线索列表**
   - 调用 `/leads/{id}/assessments` 获取评估历史
   - 显示最新评估的决策和分数

### 4.2 前端代码示例

```javascript
// LeadAssessment.jsx - 修改后的 handleSubmitAssessment

const handleSubmitAssessment = async () => {
  if (!selectedLead || !selectedLead.raw) return;

  try {
    // Step 1: 申请技术评估
    const applyResponse = await fetch(
      `http://localhost:8000/api/v1/sales/leads/${selectedLead.raw.id}/assessments/apply`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({
          evaluator_id: null // 使用当前用户
        })
      }
    );

    if (!applyResponse.ok) {
      throw new Error('申请评估失败');
    }

    const { data } = await applyResponse.json();
    const assessmentId = data.assessment_id;

    // Step 2: 执行技术评估
    const requirement_data = {
      demandClarity: assessmentScores.demand || 3,
      budgetStatus: assessmentScores.budget || 3,
      decisionAuthority: assessmentScores.authority || 3,
      timelineUrgency: assessmentScores.timeline || 3,
      solutionFit: assessmentScores.fit || 3,
      industry: selectedLead.raw.industry || "未知",
      // 可以添加更多字段...
    };

    const evaluateResponse = await fetch(
      `http://localhost:8000/api/v1/sales/assessments/${assessmentId}/evaluate`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({
          requirement_data: requirement_data,
          enable_ai: false
        })
      }
    );

    if (!evaluateResponse.ok) {
      throw new Error('执行评估失败');
    }

    const assessmentResult = await evaluateResponse.json();

    // Step 3: 显示评估结果对话框
    setAssessmentResult(assessmentResult);
    setShowAssessmentResultDialog(true);
    setShowAssessmentForm(false);

    // Step 4: 刷新线索列表
    loadLeads();

  } catch (err) {
    console.error("Failed to submit assessment:", err);
    alert("提交评估失败，请重试");
  }
};
```

### 4.3 决策等级映射

| 后端决策 | 前端显示 | 颜色 | 说明 |
|---------|---------|------|------|
| `RECOMMEND` | 推荐接单 | 绿色 | 总分≥75，无风险 |
| `CONDITIONAL` | 有条件推荐 | 黄色 | 总分60-74，有中低风险 |
| `DEFER` | 建议延期 | 橙色 | 总分40-59，有高风险 |
| `NOT_RECOMMEND` | 不建议接单 | 红色 | 总分<40 或触发一票否决 |

---

## 5. 数据迁移方案（第六阶段）

### 5.1 迁移脚本设计

将现有 `demand_summary` 中的简化评估数据迁移到 TechnicalAssessment 表：

```python
# 迁移脚本伪代码
import json
from app.models.sales import Lead, TechnicalAssessment
from app.services.technical_assessment_service import TechnicalAssessmentService

def migrate_legacy_assessments():
    """迁移旧评估数据到新模型"""
    db = get_db_session()
    service = TechnicalAssessmentService(db)

    # 查找所有包含评估数据的线索
    leads = db.query(Lead).filter(
        Lead.demand_summary.isnot(None)
    ).all()

    for lead in leads:
        try:
            demand_data = json.loads(lead.demand_summary)
            if 'assessment' not in demand_data:
                continue

            assessment_info = demand_data['assessment']
            dimensions = assessment_info.get('dimensions', {})

            # 构建 requirement_data
            requirement_data = {
                "demandClarity": dimensions.get("demand", 3),
                "budgetStatus": dimensions.get("budget", 3),
                "decisionAuthority": dimensions.get("authority", 3),
                "timelineUrgency": dimensions.get("timeline", 3),
                "solutionFit": dimensions.get("fit", 3),
                "industry": lead.industry or "未知",
            }

            # 如果线索还没有 assessment_id，创建新评估
            if not lead.assessment_id:
                assessment = service.evaluate(
                    source_type="LEAD",
                    source_id=lead.id,
                    evaluator_id=lead.owner_id or 1,
                    requirement_data=requirement_data,
                    ai_analysis=None
                )

                print(f"Migrated assessment for lead {lead.id}: score={assessment.total_score}, decision={assessment.decision}")

        except Exception as e:
            print(f"Error migrating lead {lead.id}: {e}")
            continue

    db.commit()
```

### 5.2 迁移验证

```sql
-- 检查迁移后的数据统计
SELECT
    COUNT(*) as total_leads,
    COUNT(assessment_id) as leads_with_assessment,
    COUNT(*) - COUNT(assessment_id) as leads_without_assessment
FROM leads;

-- 检查评估决策分布
SELECT
    decision,
    COUNT(*) as count
FROM technical_assessments
GROUP BY decision;
```

---

## 6. 测试计划（第七阶段）

### 6.1 后端 API 测试

```bash
# 1. 登录获取 token
TOKEN=$(curl -s -X POST http://localhost:8000/api/v1/auth/login \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=admin&password=admin123" | jq -r .access_token)

# 2. 申请技术评估
ASSESSMENT_ID=$(curl -s -X POST http://localhost:8000/api/v1/sales/leads/1/assessments/apply \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"evaluator_id": null}' | jq -r .data.assessment_id)

# 3. 执行技术评估
curl -X POST http://localhost:8000/api/v1/sales/assessments/$ASSESSMENT_ID/evaluate \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "requirement_data": {
      "demandClarity": 4,
      "budgetStatus": 5,
      "decisionAuthority": 3,
      "timelineUrgency": 4,
      "solutionFit": 4,
      "industry": "汽车电子",
      "productTypes": ["FCT"],
      "taktTimeS": 30,
      "annualVolume": 100000
    },
    "enable_ai": false
  }' | jq .

# 4. 获取评估详情
curl -X GET http://localhost:8000/api/v1/sales/assessments/$ASSESSMENT_ID \
  -H "Authorization: Bearer $TOKEN" | jq .

# 5. 获取线索的所有评估
curl -X GET http://localhost:8000/api/v1/sales/leads/1/assessments \
  -H "Authorization: Bearer $TOKEN" | jq .
```

### 6.2 前端功能测试

#### 测试场景 1：高分推荐
- 需求明确度: 5
- 预算充足度: 5
- 决策权限: 4
- 时间紧迫度: 4
- 方案匹配度: 5
- **预期结果**: RECOMMEND（推荐接单），总分≥75

#### 测试场景 2：有条件推荐
- 需求明确度: 4
- 预算充足度: 3
- 决策权限: 3
- 时间紧迫度: 5
- 方案匹配度: 3
- **预期结果**: CONDITIONAL（有条件推荐），总分60-74，显示风险和条件

#### 测试场景 3：低分不推荐
- 需求明确度: 2
- 预算充足度: 2
- 决策权限: 2
- 时间紧迫度: 2
- 方案匹配度: 2
- **预期结果**: NOT_RECOMMEND（不推荐接单），总分<40

### 6.3 数据一致性测试

```sql
-- 测试 1: 确认所有新创建的线索都关联了评估
SELECT
    l.id,
    l.lead_code,
    l.assessment_id,
    ta.decision,
    ta.total_score
FROM leads l
LEFT JOIN technical_assessments ta ON l.assessment_id = ta.id
WHERE l.created_at > '2026-01-13'
ORDER BY l.created_at DESC
LIMIT 10;

-- 测试 2: 确认评估历史完整性
SELECT
    COUNT(*) as total_assessments,
    COUNT(DISTINCT source_id) as unique_leads,
    AVG(total_score) as avg_score
FROM technical_assessments
WHERE source_type = 'LEAD';
```

---

## 7. 附录

### 7.1 评分规则配置示例

TechnicalAssessmentService 使用 ScoringRule 表中的配置（JSON 格式）：

```json
{
  "dimensions": {
    "technology": {
      "weight": 0.2,
      "max_score": 20,
      "criteria": [
        {"range": [4, 5], "score": 20, "description": "需求非常明确"},
        {"range": [3, 4], "score": 15, "description": "需求比较明确"},
        {"range": [0, 3], "score": 10, "description": "需求不够明确"}
      ]
    },
    "business": {
      "weight": 0.2,
      "max_score": 20
    },
    "resource": {
      "weight": 0.2,
      "max_score": 20
    },
    "delivery": {
      "weight": 0.2,
      "max_score": 20
    },
    "customer": {
      "weight": 0.2,
      "max_score": 20
    }
  },
  "decision_thresholds": {
    "RECOMMEND": 75,
    "CONDITIONAL": 60,
    "DEFER": 40,
    "NOT_RECOMMEND": 0
  },
  "veto_rules": [
    {
      "name": "预算不足",
      "condition": "budgetStatus < 2",
      "description": "预算明显不足，无法覆盖成本"
    },
    {
      "name": "交期不可行",
      "condition": "timelineUrgency == 5 && deliveryMonths < 2",
      "description": "交期要求过紧，无法保证质量"
    }
  ]
}
```

### 7.2 失败案例匹配算法

TechnicalAssessmentService 使用以下相似度计算方法：

```python
def calculate_similarity(case, requirement_data):
    """
    计算失败案例与当前需求的相似度 (0-1)
    """
    score = 0.0

    # 行业匹配 (30%)
    if case.industry == requirement_data.get('industry'):
        score += 0.3

    # 产品类型匹配 (30%)
    case_products = set(json.loads(case.product_types))
    req_products = set(requirement_data.get('productTypes', []))
    if case_products & req_products:
        score += 0.3

    # 节拍时间相似度 (20%)
    if case.takt_time_s and requirement_data.get('taktTimeS'):
        time_diff = abs(case.takt_time_s - requirement_data['taktTimeS'])
        time_similarity = max(0, 1 - time_diff / 60)  # 60秒内相似
        score += 0.2 * time_similarity

    # 预算状态匹配 (10%)
    if case.budget_status == requirement_data.get('budgetStatus'):
        score += 0.1

    # 年产量相似度 (10%)
    if case.annual_volume and requirement_data.get('annualVolume'):
        volume_ratio = min(case.annual_volume, requirement_data['annualVolume']) / \
                       max(case.annual_volume, requirement_data['annualVolume'])
        score += 0.1 * volume_ratio

    return score
```

---

## 8. 后续优化建议

1. **AI 分析增强**
   - 集成大语言模型分析需求描述
   - 自动识别潜在风险点
   - 生成个性化的建议

2. **评分规则可配置化**
   - 前端界面管理评分规则
   - 支持多版本规则切换
   - A/B 测试不同评分策略

3. **失败案例知识库建设**
   - 收集更多历史失败案例
   - 标准化案例字段
   - 定期更新和维护

4. **评估流程优化**
   - 支持多人协同评估
   - 评估审批流程
   - 评估报告导出

---

**文档结束**

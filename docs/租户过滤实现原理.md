# 租户过滤实现原理

## 概述

本文档详细说明非标自动化项目管理系统中**框架级强制租户过滤**的实现原理、技术细节和使用方法。

## 目录

1. [背景与目标](#背景与目标)
2. [核心架构](#核心架构)
3. [技术实现](#技术实现)
4. [使用指南](#使用指南)
5. [安全保障](#安全保障)
6. [性能优化](#性能优化)
7. [常见问题](#常见问题)

---

## 背景与目标

### 问题陈述

在多租户SaaS系统中，数据隔离是最重要的安全要求之一。传统的手动过滤方式存在以下问题：

1. **容易遗漏**：开发人员可能忘记添加 `filter(Model.tenant_id == tenant_id)`
2. **代码重复**：每个查询都要手动添加过滤条件
3. **维护成本高**：修改过滤逻辑需要改动大量代码
4. **安全风险**：一处遗漏就可能导致数据泄露

### 解决方案

实现**框架级自动租户过滤**，确保：

- ✅ 所有查询自动添加租户过滤条件
- ✅ 无需手动添加过滤逻辑
- ✅ 框架级保障，不依赖开发人员记忆
- ✅ 支持超级管理员访问所有数据
- ✅ 防御性编程，无效状态抛出异常

---

## 核心架构

### 系统组成

```
┌─────────────────────────────────────────────────────────┐
│                    API Endpoint Layer                   │
│  @require_tenant_isolation / @allow_cross_tenant        │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              Middleware Layer (租户上下文)               │
│  TenantContextMiddleware → ContextVar[tenant_id]        │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│               Database Query Layer                      │
│  TenantQuery → 自动添加 WHERE tenant_id = ?             │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│            Permission Check Layer                       │
│  check_tenant_access() → 验证资源访问权限                │
└─────────────────────────────────────────────────────────┘
```

### 数据流向

```
用户请求
  ↓
认证中间件 (GlobalAuthMiddleware)
  ↓ request.state.user
租户上下文中间件 (TenantContextMiddleware)
  ↓ set_current_tenant_id(user.tenant_id)
API 端点处理 (@require_tenant_isolation)
  ↓ db.info['tenant_id'] = current_user.tenant_id
数据库查询 (db.query(Model))
  ↓ TenantQuery.__iter__()
自动添加过滤 (filter(Model.tenant_id == tenant_id))
  ↓
返回租户数据
```

---

## 技术实现

### 1. TenantQuery - 自动过滤核心

#### 文件位置
`app/core/database/tenant_query.py`

#### 关键代码

```python
class TenantQuery(Query):
    """自动添加租户过滤的Query类"""
    
    def __iter__(self):
        """在查询执行前自动添加租户过滤"""
        if getattr(self, '_skip_tenant_filter', False):
            return super().__iter__()
        
        return self._apply_tenant_filter().__iter__()
    
    def _apply_tenant_filter(self):
        """应用租户过滤逻辑"""
        tenant_id = get_current_tenant_id()
        model = self.column_descriptions[0].get('type')
        
        if not hasattr(model, 'tenant_id'):
            return self  # 模型没有 tenant_id 字段，跳过
        
        if tenant_id is None:
            # 超级管理员验证
            user = self._get_current_user_from_context()
            if user and not user.is_superuser:
                raise ValueError("Invalid user: tenant_id=None but is_superuser=False")
            return self  # 超级管理员，不过滤
        
        # 添加租户过滤
        return self.filter(model.tenant_id == tenant_id)
```

#### 工作原理

1. **拦截查询执行**：重写 `__iter__()` 方法，在查询真正执行前介入
2. **检查模型**：判断模型是否有 `tenant_id` 字段
3. **获取租户ID**：从上下文变量获取当前租户ID
4. **权限验证**：超级管理员可访问所有数据，普通用户强制过滤
5. **添加条件**：自动添加 `WHERE tenant_id = ?` 条件

#### 优势

- ✅ **透明性**：开发人员无需关心过滤逻辑
- ✅ **强制性**：框架级保障，无法绕过（除非显式禁用）
- ✅ **灵活性**：支持禁用过滤（`.skip_tenant_filter()`）
- ✅ **兼容性**：不影响没有 `tenant_id` 字段的模型

---

### 2. SessionLocal 配置

#### 文件位置
`app/models/base.py`

#### 关键代码

```python
def get_session_factory():
    """获取session工厂"""
    global _SessionLocal
    if _SessionLocal is None:
        engine = get_engine()
        from app.core.database.tenant_query import TenantQuery
        
        _SessionLocal = sessionmaker(
            autocommit=False,
            autoflush=False,
            bind=engine,
            class_=RuntimePatchedSession,
            query_cls=TenantQuery,  # 使用租户感知的Query类
        )
    return _SessionLocal
```

#### 说明

所有通过 `get_db()` 依赖注入的数据库会话都会使用 `TenantQuery`，确保全局生效。

---

### 3. API 装饰器

#### 文件位置
`app/core/decorators/tenant_isolation.py`

#### @require_tenant_isolation

强制API端点执行租户隔离：

```python
@router.get("/projects")
@require_tenant_isolation
async def list_projects(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    # 查询会自动过滤
    projects = db.query(Project).all()
    return projects
```

**功能**：
1. 验证 `db` 和 `current_user` 参数存在
2. 将租户信息存入 `db.info['tenant_id']`
3. 确保后续查询能获取到租户上下文

#### @allow_cross_tenant

允许跨租户访问（仅超级管理员）：

```python
@router.get("/admin/all-projects")
@allow_cross_tenant(admin_only=True)
async def list_all_projects(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    query = db.query(Project)
    query._skip_tenant_filter = True
    return query.all()
```

**功能**：
1. 验证用户是超级管理员
2. 允许访问所有租户的数据
3. 需要显式禁用过滤（`._skip_tenant_filter = True`）

---

### 4. 资源访问权限检查

#### 文件位置
`app/core/permissions/tenant_access.py`

#### check_tenant_access()

核心权限检查函数：

```python
def check_tenant_access(user, resource_tenant_id) -> bool:
    """检查用户是否有权访问指定租户的资源"""
    user_tenant_id = user.tenant_id
    is_superuser = user.is_superuser
    
    # 规则1：超级管理员可访问所有数据
    if is_superuser and user_tenant_id is None:
        return True
    
    # 规则2：系统级资源所有用户可访问
    if resource_tenant_id is None:
        return True
    
    # 规则3：同一租户
    return user_tenant_id == resource_tenant_id
```

#### ensure_tenant_consistency()

确保创建资源时使用正确的租户ID：

```python
@router.post("/projects")
async def create_project(data: ProjectCreate, current_user: User = Depends(get_current_user)):
    project_dict = data.dict()
    project_dict = ensure_tenant_consistency(current_user, project_dict)
    project = Project(**project_dict)
    db.add(project)
    db.commit()
    return project
```

**功能**：
1. 验证请求中的 `tenant_id` 是否合法
2. 自动设置为当前用户的租户ID
3. 防止普通用户创建其他租户的资源

---

## 使用指南

### 开发新 API

#### 标准业务 API

```python
from app.core.decorators import require_tenant_isolation

@router.get("/orders")
@require_tenant_isolation
async def list_orders(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    # 自动过滤当前租户的订单
    orders = db.query(Order).filter(Order.status == "pending").all()
    return orders
```

**要点**：
- ✅ 使用 `@require_tenant_isolation` 装饰器
- ✅ 参数中包含 `db` 和 `current_user`
- ✅ 查询会自动添加 `tenant_id` 过滤
- ❌ 不需要手动添加 `filter(Order.tenant_id == ...)`

#### 系统管理 API

```python
from app.core.decorators import allow_cross_tenant

@router.get("/admin/statistics")
@allow_cross_tenant(admin_only=True)
async def get_statistics(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    # 需要显式禁用过滤
    query = db.query(Order)
    query._skip_tenant_filter = True
    total = query.count()
    return {"total_orders": total}
```

**要点**：
- ✅ 使用 `@allow_cross_tenant(admin_only=True)` 装饰器
- ✅ 显式禁用过滤：`query._skip_tenant_filter = True`
- ⚠️ 仅限超级管理员访问

### 创建资源

```python
from app.core.permissions.tenant_access import ensure_tenant_consistency

@router.post("/customers")
@require_tenant_isolation
async def create_customer(
    data: CustomerCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    # 自动设置租户ID
    customer_dict = data.dict()
    customer_dict = ensure_tenant_consistency(current_user, customer_dict)
    
    customer = Customer(**customer_dict)
    db.add(customer)
    db.commit()
    db.refresh(customer)
    return customer
```

### 验证资源访问

```python
from app.core.decorators import tenant_resource_check

@router.put("/projects/{project_id}")
@require_tenant_isolation
async def update_project(
    project_id: int,
    data: ProjectUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    project = db.query(Project).filter(Project.id == project_id).first()
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # 显式验证访问权限
    tenant_resource_check(current_user, project.tenant_id, "Project")
    
    # 更新项目
    for key, value in data.dict(exclude_unset=True).items():
        setattr(project, key, value)
    
    db.commit()
    db.refresh(project)
    return project
```

---

## 安全保障

### 1. 防御性编程

```python
# 无效状态会抛出异常
if tenant_id is None and not user.is_superuser:
    raise ValueError("Invalid user: tenant_id=None but is_superuser=False")
```

### 2. 日志记录

所有租户访问都会记录日志：

```python
logger.debug(f"Tenant filter applied: model={model.__name__}, tenant_id={tenant_id}")
logger.warning(f"Tenant access denied: user_tenant={user_tenant}, resource_tenant={resource_tenant}")
```

### 3. 多层防护

1. **中间件层**：设置租户上下文
2. **Query层**：自动过滤查询
3. **装饰器层**：验证API权限
4. **业务层**：显式检查资源访问

### 4. 审计追踪

建议在重要操作中记录审计日志：

```python
logger.info(
    f"User {current_user.id} (tenant={current_user.tenant_id}) "
    f"accessed resource {resource_id} (tenant={resource.tenant_id})"
)
```

---

## 性能优化

### 1. 索引优化

确保所有有 `tenant_id` 字段的表都有复合索引：

```sql
CREATE INDEX idx_projects_tenant_id ON projects(tenant_id, created_at);
CREATE INDEX idx_orders_tenant_id ON orders(tenant_id, status);
```

### 2. 查询优化

自动过滤会在 WHERE 子句中添加条件，与手动过滤性能相同：

```sql
-- 自动生成的SQL
SELECT * FROM projects WHERE tenant_id = 100 AND status = 'active';
```

### 3. 避免重复检查

`TenantQuery` 会检查是否已有租户过滤，避免重复添加。

---

## 常见问题

### Q1: 如何查询系统级资源？

A: 系统级资源（如字典表）的 `tenant_id` 应为 `NULL`，这样所有用户都能访问。

### Q2: 如何禁用自动过滤？

A: 使用 `.skip_tenant_filter()` 方法：

```python
query = db.query(Project).skip_tenant_filter()
all_projects = query.all()
```

### Q3: 超级管理员如何查看所有数据？

A: 超级管理员的 `tenant_id` 应为 `None` 且 `is_superuser=True`，会自动跳过过滤。

### Q4: 如何处理跨表关联？

A: 关联查询也会自动过滤：

```python
# 两个表都会自动过滤
results = db.query(Order, Customer).join(Customer).all()
```

### Q5: 性能影响如何？

A: 几乎没有影响，生成的SQL与手动添加过滤条件相同。

---

## 总结

框架级强制租户过滤提供了：

✅ **安全性**：框架级保障，防止数据泄露  
✅ **便捷性**：自动过滤，无需手动处理  
✅ **灵活性**：支持超级管理员和系统级资源  
✅ **可维护性**：集中管理，易于修改和审计  

## 相关文档

- [API 开发最佳实践](./API开发最佳实践.md)
- [多租户架构设计](./多租户架构设计.md)
- [权限系统说明](./权限系统说明.md)

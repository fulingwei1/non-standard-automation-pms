# 生产工作台数据补充实现方案

> 生成日期：2025-01-15  
> 基于实际需求：人员绩效、项目进展、客服/仓储/发货真实数据、缺料找料数据

---

## 一、需求分析

### 1.1 核心需求

根据实际业务情况，重点关注：

1. **人员绩效与项目进展情况**
   - 生产人员绩效排名和统计
   - 在产项目进度详情
   - 项目里程碑完成情况

2. **客服、仓储、发货部的真实数据**
   - 客服：服务案例、客户满意度、响应时间
   - 仓储：库存数据、库存周转、仓储利用率
   - 发货：发货订单、发货准时率、在途订单

3. **缺物料、找物料的数据**
   - 缺料预警统计
   - 物料查找功能
   - 物料替代和调拨情况

---

## 二、现有API和数据源

### 2.1 人员绩效相关 ✅

**已有API**：
- `GET /production/reports/worker-performance` - 人员绩效报表
  - 支持按工人ID、车间ID筛选
  - 支持按日期范围统计
  - 返回：工时、完成工单数、完成数量、合格数量、平均效率

**数据模型**：
- `Worker` - 工人表
- `WorkReport` - 报工记录表
- `WorkOrder` - 工单表

**缺失**：
- ❌ 人员绩效排名API（按效率、产出等排序）
- ❌ 人员绩效趋势分析
- ❌ 人员绩效对比（车间间、个人间）

---

### 2.2 项目进展相关 ✅

**已有API**：
- `GET /projects` - 项目列表
- `GET /projects/{id}` - 项目详情
- `GET /projects/{id}/milestones` - 项目里程碑
- `GET /projects/{id}/stages` - 项目阶段

**数据模型**：
- `Project` - 项目表（包含stage、health等字段）
- `ProjectStage` - 项目阶段表
- `ProjectMilestone` - 项目里程碑表
- `ProjectStatus` - 项目状态表

**缺失**：
- ❌ 在产项目进度汇总API（专门给生产总监/经理看）
- ❌ 项目延期风险预警
- ❌ 项目资源占用情况

---

### 2.3 客服部数据 ✅

**已有API**：
- `GET /service-tickets` - 服务工单列表
- `GET /service-tickets/statistics` - 服务工单统计
- `GET /customer-satisfactions` - 客户满意度调查
- `GET /customer-satisfactions/statistics` - 满意度统计

**数据模型**：
- `ServiceTicket` - 服务工单表
- `ServiceRecord` - 服务记录表
- `CustomerSatisfaction` - 客户满意度表

**当前状态**：
- ✅ API已实现
- ⚠️ 生产总监工作台使用的是Mock数据，需要对接真实API

---

### 2.4 仓储部数据 ⚠️

**已有API**：
- `GET /materials` - 物料列表（包含库存信息）
- `GET /materials/{id}` - 物料详情
- `GET /material-demands/vs-stock` - 物料需求vs库存对比

**数据模型**：
- `Material` - 物料表（包含`current_stock`、`safety_stock`等字段）
- `GoodsReceipt` - 入库单表
- `GoodsReceiptItem` - 入库明细表

**缺失**：
- ❌ 仓储统计API（库存SKU数、库存周转率、仓储利用率）
- ❌ 库存预警API（低库存、缺货）
- ❌ 入库/出库统计

**当前状态**：
- ⚠️ 生产总监工作台使用的是Mock数据
- ⚠️ 需要新增仓储统计API

---

### 2.5 发货部数据 ✅

**已有API**：
- `GET /business-support/delivery-orders` - 发货单列表
- `GET /business-support/delivery-orders/{id}` - 发货单详情

**数据模型**：
- `DeliveryOrder` - 发货单表
  - `delivery_status` - 发货状态（draft/approved/printed/shipped/received/returned）
  - `delivery_date` - 发货日期
  - `ship_date` - 实际发货时间
  - `receive_date` - 客户签收日期

**缺失**：
- ❌ 发货统计API（待发货数、今日已发、准时发货率、在途订单）
- ❌ 发货准时率计算逻辑

**当前状态**：
- ⚠️ 生产总监工作台使用的是Mock数据
- ⚠️ 需要新增发货统计API

---

### 2.6 缺料找料数据 ✅

**已有API**：
- `GET /shortage/reports` - 缺料上报列表
- `GET /shortage/statistics/daily-report` - 缺料日报统计
- `GET /shortage/statistics/latest-daily-report` - 最新缺料日报
- `GET /shortage/substitutions` - 物料替代列表
- `GET /shortage/transfers` - 物料调拨列表
- `GET /material-demands` - 物料需求列表
- `GET /material-demands/vs-stock` - 物料需求vs库存对比

**数据模型**：
- `ShortageReport` - 缺料上报表
- `MaterialArrival` - 到货跟踪表
- `MaterialSubstitution` - 物料替代表
- `MaterialTransfer` - 物料调拨表
- `MaterialRequirement` - 物料需求汇总表
- `ShortageDailyReport` - 缺料日报统计表

**当前状态**：
- ✅ API已实现
- ✅ 生产部经理工作台已展示缺料日报
- ⚠️ 需要增强物料查找功能展示

---

## 三、实现方案

### 3.1 人员绩效与项目进展

#### 3.1.1 新增API：人员绩效排名

**文件**：`app/api/v1/endpoints/production.py`

```python
@router.get("/reports/worker-ranking", response_model=List[WorkerRankingResponse])
def get_worker_ranking(
    db: Session = Depends(deps.get_db),
    ranking_type: str = Query("efficiency", description="排名类型：efficiency/output/quality"),
    workshop_id: Optional[int] = Query(None, description="车间ID筛选"),
    period_start: date = Query(..., description="统计开始日期"),
    period_end: date = Query(..., description="统计结束日期"),
    limit: int = Query(10, description="返回前N名"),
    current_user: User = Depends(security.require_production_access()),
) -> Any:
    """
    人员绩效排名
    ranking_type: efficiency(效率) / output(产出) / quality(质量)
    """
    # 获取工人绩效数据
    workers = db.query(Worker).filter(Worker.status == "ACTIVE")
    if workshop_id:
        workers = workers.filter(Worker.workshop_id == workshop_id)
    workers = workers.all()
    
    rankings = []
    for worker in workers:
        # 查询报工记录
        reports = db.query(WorkReport).filter(
            WorkReport.worker_id == worker.id,
            WorkReport.report_time >= datetime.combine(period_start, datetime.min.time()),
            WorkReport.report_time <= datetime.combine(period_end, datetime.max.time())
        ).all()
        
        # 计算指标
        total_hours = sum(float(r.work_hours) if r.work_hours else 0 for r in reports)
        total_completed_qty = sum(r.completed_qty or 0 for r in reports)
        total_qualified_qty = sum(r.qualified_qty or 0 for r in reports)
        
        # 计算效率
        work_orders = db.query(WorkOrder).filter(
            WorkOrder.assigned_to == worker.id,
            WorkOrder.status == "COMPLETED",
            WorkOrder.actual_end_time >= datetime.combine(period_start, datetime.min.time()),
            WorkOrder.actual_end_time <= datetime.combine(period_end, datetime.max.time())
        ).all()
        
        efficiencies = []
        for wo in work_orders:
            if wo.standard_hours and wo.actual_hours and wo.actual_hours > 0:
                eff = float((wo.standard_hours / wo.actual_hours) * 100)
                efficiencies.append(eff)
        
        average_efficiency = sum(efficiencies) / len(efficiencies) if efficiencies else 0.0
        quality_rate = (total_qualified_qty / total_completed_qty * 100) if total_completed_qty > 0 else 0.0
        
        # 根据排名类型选择排序指标
        if ranking_type == "efficiency":
            score = average_efficiency
        elif ranking_type == "output":
            score = total_completed_qty
        elif ranking_type == "quality":
            score = quality_rate
        else:
            score = average_efficiency
        
        rankings.append({
            "worker_id": worker.id,
            "worker_name": worker.worker_name,
            "workshop_name": worker.workshop.workshop_name if worker.workshop else None,
            "efficiency": average_efficiency,
            "output": total_completed_qty,
            "quality_rate": quality_rate,
            "total_hours": total_hours,
            "score": score
        })
    
    # 排序
    rankings.sort(key=lambda x: x["score"], reverse=True)
    
    # 添加排名
    for idx, ranking in enumerate(rankings[:limit], 1):
        ranking["rank"] = idx
    
    return rankings[:limit]
```

---

#### 3.1.2 新增API：在产项目进度汇总

**文件**：`app/api/v1/endpoints/projects.py`

```python
@router.get("/projects/in-production/summary", response_model=List[InProductionProjectSummary])
def get_in_production_projects_summary(
    db: Session = Depends(deps.get_db),
    stage: Optional[str] = Query(None, description="阶段筛选：S4-S8"),
    health: Optional[str] = Query(None, description="健康度筛选：H1-H3"),
    current_user: User = Depends(security.require_production_access()),
) -> Any:
    """
    在产项目进度汇总（专门给生产总监/经理看）
    """
    # 查询在产项目（S4-S8阶段）
    query = db.query(Project).filter(
        Project.stage.in_(["S4", "S5", "S6", "S7", "S8"]),
        Project.is_active == True
    )
    
    if stage:
        query = query.filter(Project.stage == stage)
    if health:
        query = query.filter(Project.health == health)
    
    projects = query.all()
    
    result = []
    for project in projects:
        # 获取项目阶段信息
        stages = db.query(ProjectStage).filter(
            ProjectStage.project_id == project.id
        ).order_by(ProjectStage.stage_order).all()
        
        # 获取里程碑信息
        milestones = db.query(ProjectMilestone).filter(
            ProjectMilestone.project_id == project.id,
            ProjectMilestone.status != "COMPLETED"
        ).order_by(ProjectMilestone.planned_date).limit(5).all()
        
        # 计算项目进度（基于阶段完成情况）
        completed_stages = sum(1 for s in stages if s.status == "COMPLETED")
        total_stages = len(stages)
        progress = (completed_stages / total_stages * 100) if total_stages > 0 else 0
        
        # 获取延期风险
        overdue_milestones = [
            m for m in milestones 
            if m.planned_date < date.today() and m.status != "COMPLETED"
        ]
        
        result.append({
            "project_id": project.id,
            "project_code": project.project_code,
            "project_name": project.project_name,
            "stage": project.stage,
            "health": project.health,
            "progress": progress,
            "planned_end_date": project.planned_end_date,
            "actual_end_date": project.actual_end_date,
            "overdue_milestones_count": len(overdue_milestones),
            "next_milestone": milestones[0].milestone_name if milestones else None,
            "next_milestone_date": milestones[0].planned_date if milestones else None,
        })
    
    return result
```

---

### 3.2 客服部真实数据对接

#### 3.2.1 新增API：客服统计（给生产总监看）

**文件**：`app/api/v1/endpoints/service.py`

```python
@router.get("/service/dashboard-statistics", response_model=ServiceDashboardStatistics)
def get_service_dashboard_statistics(
    db: Session = Depends(deps.get_db),
    current_user: User = Depends(security.get_current_active_user),
) -> Any:
    """
    客服部统计（给生产总监看）
    """
    today = date.today()
    
    # 服务案例统计
    active_cases = db.query(ServiceTicket).filter(
        ServiceTicket.status.in_(["PENDING", "IN_PROGRESS"])
    ).count()
    
    resolved_today = db.query(ServiceTicket).filter(
        ServiceTicket.status == "RESOLVED",
        ServiceTicket.resolved_at >= datetime.combine(today, datetime.min.time())
    ).count()
    
    pending_cases = db.query(ServiceTicket).filter(
        ServiceTicket.status == "PENDING"
    ).count()
    
    # 平均响应时间（从服务记录中计算）
    from app.models.service import ServiceRecord
    records = db.query(ServiceRecord).filter(
        ServiceRecord.response_time.isnot(None)
    ).all()
    
    avg_response_time = 0.0
    if records:
        total_time = sum(float(r.response_time) for r in records if r.response_time)
        avg_response_time = total_time / len(records) if len(records) > 0 else 0.0
    
    # 客户满意度
    from app.models.service import CustomerSatisfaction
    completed_surveys = db.query(CustomerSatisfaction).filter(
        CustomerSatisfaction.status == "COMPLETED",
        CustomerSatisfaction.overall_score.isnot(None)
    ).all()
    
    customer_satisfaction = 0.0
    if completed_surveys:
        total_score = sum(float(s.overall_score) for s in completed_surveys)
        customer_satisfaction = (total_score / len(completed_surveys)) * 20  # 转换为百分制
    
    # 在岗工程师
    from app.models.user import User
    from app.models.organization import UserRole, Role
    engineer_role = db.query(Role).filter(Role.role_code == "customer_service_engineer").first()
    if engineer_role:
        total_engineers = db.query(User).join(UserRole).filter(
            UserRole.role_id == engineer_role.id,
            User.is_active == True
        ).count()
        # 简化处理：假设所有工程师都在岗
        active_engineers = total_engineers
    else:
        total_engineers = 0
        active_engineers = 0
    
    # 现场服务
    on_site_services = db.query(ServiceTicket).filter(
        ServiceTicket.service_type == "ON_SITE",
        ServiceTicket.status.in_(["PENDING", "IN_PROGRESS"])
    ).count()
    
    return {
        "active_cases": active_cases,
        "resolved_today": resolved_today,
        "pending_cases": pending_cases,
        "avg_response_time": avg_response_time,
        "customer_satisfaction": customer_satisfaction,
        "on_site_services": on_site_services,
        "total_engineers": total_engineers,
        "active_engineers": active_engineers,
    }
```

---

### 3.3 仓储部真实数据对接

#### 3.3.1 新增API：仓储统计

**文件**：`app/api/v1/endpoints/material.py`（或新建`warehouse.py`）

```python
@router.get("/warehouse/statistics", response_model=WarehouseStatistics)
def get_warehouse_statistics(
    db: Session = Depends(deps.get_db),
    current_user: User = Depends(security.get_current_active_user),
) -> Any:
    """
    仓储统计（给生产总监看）
    """
    # 库存SKU统计
    total_items = db.query(Material).count()
    in_stock_items = db.query(Material).filter(
        Material.current_stock > 0
    ).count()
    
    # 低库存预警
    low_stock_items = db.query(Material).filter(
        Material.current_stock < Material.safety_stock,
        Material.current_stock > 0
    ).count()
    
    # 缺货
    out_of_stock_items = db.query(Material).filter(
        Material.current_stock <= 0
    ).count()
    
    # 库存周转率（简化计算：本月出库金额 / 平均库存金额）
    from app.models.purchase import GoodsReceiptItem
    from datetime import timedelta
    today = date.today()
    month_start = date(today.year, today.month, 1)
    
    # 本月入库金额（简化：从入库单计算）
    inbound_amount = db.query(func.sum(GoodsReceiptItem.amount)).filter(
        GoodsReceiptItem.created_at >= datetime.combine(month_start, datetime.min.time())
    ).scalar() or 0
    
    # 平均库存金额（简化：当前库存金额）
    avg_inventory_amount = db.query(func.sum(
        Material.current_stock * Material.unit_price
    )).scalar() or 0
    
    inventory_turnover = 0.0
    if avg_inventory_amount > 0:
        inventory_turnover = float(inbound_amount) / float(avg_inventory_amount)
    
    # 仓储利用率（简化：假设有仓储容量字段，这里用Mock数据）
    warehouse_utilization = 82.3  # TODO: 从仓储容量表计算
    
    # 待入库/待出库
    from app.models.purchase import PurchaseOrder, PurchaseOrderItem
    pending_inbound = db.query(PurchaseOrder).filter(
        PurchaseOrder.status.in_(["APPROVED", "ORDERED", "PARTIAL_RECEIVED"])
    ).count()
    
    # 待出库（从工单领料需求计算）
    from app.models.production import WorkOrder
    pending_outbound = db.query(WorkOrder).filter(
        WorkOrder.status.in_(["ASSIGNED", "STARTED"]),
        # 假设有领料状态字段
    ).count()
    
    return {
        "total_items": total_items,
        "in_stock_items": in_stock_items,
        "low_stock_items": low_stock_items,
        "out_of_stock_items": out_of_stock_items,
        "inventory_turnover": inventory_turnover,
        "warehouse_utilization": warehouse_utilization,
        "pending_inbound": pending_inbound,
        "pending_outbound": pending_outbound,
    }
```

---

### 3.4 发货部真实数据对接

#### 3.4.1 新增API：发货统计

**文件**：`app/api/v1/endpoints/business_support_orders.py`

```python
@router.get("/delivery-orders/statistics", response_model=DeliveryStatistics)
def get_delivery_statistics(
    db: Session = Depends(deps.get_db),
    current_user: User = Depends(security.get_current_active_user),
) -> Any:
    """
    发货统计（给生产总监看）
    """
    today = date.today()
    
    # 待发货
    pending_shipments = db.query(DeliveryOrder).filter(
        DeliveryOrder.delivery_status == "approved"
    ).count()
    
    # 今日已发
    shipped_today = db.query(DeliveryOrder).filter(
        DeliveryOrder.delivery_status == "shipped",
        DeliveryOrder.ship_date >= datetime.combine(today, datetime.min.time())
    ).count()
    
    # 在途订单
    in_transit = db.query(DeliveryOrder).filter(
        DeliveryOrder.delivery_status == "shipped",
        DeliveryOrder.receive_date.is_(None)
    ).count()
    
    # 本周已送达
    week_start = today - timedelta(days=today.weekday())
    delivered_this_week = db.query(DeliveryOrder).filter(
        DeliveryOrder.delivery_status == "received",
        DeliveryOrder.receive_date >= week_start
    ).count()
    
    # 准时发货率（计划发货日期 vs 实际发货日期）
    all_shipped = db.query(DeliveryOrder).filter(
        DeliveryOrder.delivery_status.in_(["shipped", "received"]),
        DeliveryOrder.delivery_date.isnot(None),
        DeliveryOrder.ship_date.isnot(None)
    ).all()
    
    on_time_count = 0
    for order in all_shipped:
        if order.ship_date.date() <= order.delivery_date:
            on_time_count += 1
    
    on_time_shipping_rate = (on_time_count / len(all_shipped) * 100) if all_shipped else 0.0
    
    # 平均发货时间（从发货到签收）
    delivered_orders = db.query(DeliveryOrder).filter(
        DeliveryOrder.delivery_status == "received",
        DeliveryOrder.ship_date.isnot(None),
        DeliveryOrder.receive_date.isnot(None)
    ).all()
    
    avg_shipping_time = 0.0
    if delivered_orders:
        total_days = sum(
            (order.receive_date - order.ship_date.date()).days 
            for order in delivered_orders
        )
        avg_shipping_time = total_days / len(delivered_orders) if delivered_orders else 0.0
    
    # 总订单数
    total_orders = db.query(DeliveryOrder).count()
    
    return {
        "pending_shipments": pending_shipments,
        "shipped_today": shipped_today,
        "in_transit": in_transit,
        "delivered_this_week": delivered_this_week,
        "on_time_shipping_rate": on_time_shipping_rate,
        "avg_shipping_time": avg_shipping_time,
        "total_orders": total_orders,
    }
```

---

### 3.5 缺料找料数据增强

#### 3.5.1 新增API：物料查找

**文件**：`app/api/v1/endpoints/material.py`

```python
@router.get("/materials/search", response_model=PaginatedResponse[MaterialSearchResponse])
def search_materials(
    db: Session = Depends(deps.get_db),
    keyword: str = Query(..., description="搜索关键词（物料编码/名称/规格）"),
    has_stock: Optional[bool] = Query(None, description="是否有库存"),
    category: Optional[str] = Query(None, description="物料类别"),
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    current_user: User = Depends(security.get_current_active_user),
) -> Any:
    """
    物料查找（支持编码/名称/规格搜索）
    """
    query = db.query(Material)
    
    # 关键词搜索
    if keyword:
        query = query.filter(
            or_(
                Material.material_code.like(f"%{keyword}%"),
                Material.material_name.like(f"%{keyword}%"),
                Material.specification.like(f"%{keyword}%")
            )
        )
    
    # 库存筛选
    if has_stock is not None:
        if has_stock:
            query = query.filter(Material.current_stock > 0)
        else:
            query = query.filter(Material.current_stock <= 0)
    
    # 类别筛选
    if category:
        query = query.filter(Material.category == category)
    
    # 分页
    total = query.count()
    materials = query.offset((page - 1) * page_size).limit(page_size).all()
    
    items = []
    for material in materials:
        # 计算在途数量
        from app.models.purchase import PurchaseOrderItem, PurchaseOrder
        in_transit_qty = db.query(func.sum(PurchaseOrderItem.quantity - PurchaseOrderItem.received_qty)).join(
            PurchaseOrder, PurchaseOrderItem.po_id == PurchaseOrder.id
        ).filter(
            PurchaseOrderItem.material_id == material.id,
            PurchaseOrder.status.in_(["APPROVED", "ORDERED", "PARTIAL_RECEIVED"])
        ).scalar() or 0
        
        # 可用数量 = 当前库存 + 在途数量
        available_qty = (material.current_stock or 0) + in_transit_qty
        
        items.append({
            "material_id": material.id,
            "material_code": material.material_code,
            "material_name": material.material_name,
            "specification": material.specification,
            "category": material.category,
            "current_stock": float(material.current_stock or 0),
            "safety_stock": float(material.safety_stock or 0),
            "in_transit_qty": float(in_transit_qty),
            "available_qty": float(available_qty),
            "unit": material.unit,
            "unit_price": float(material.unit_price or 0),
            "supplier_name": material.supplier.supplier_name if material.supplier else None,
        })
    
    return {
        "items": items,
        "total": total,
        "page": page,
        "page_size": page_size,
        "pages": (total + page_size - 1) // page_size
    }
```

---

## 四、前端实现

### 4.1 生产部经理工作台增强

**文件**：`frontend/src/pages/ProductionManagerDashboard.jsx`

#### 4.1.1 新增Tab：人员绩效

```jsx
<TabsContent value="performance" className="space-y-6">
  {/* 人员绩效排名 */}
  <Card>
    <CardHeader>
      <CardTitle>人员绩效排名</CardTitle>
    </CardHeader>
    <CardContent>
      <Tabs defaultValue="efficiency">
        <TabsList>
          <TabsTrigger value="efficiency">效率排名</TabsTrigger>
          <TabsTrigger value="output">产出排名</TabsTrigger>
          <TabsTrigger value="quality">质量排名</TabsTrigger>
        </TabsList>
        <TabsContent value="efficiency">
          {/* 调用 /production/reports/worker-ranking?ranking_type=efficiency */}
        </TabsContent>
        {/* ... */}
      </Tabs>
    </CardContent>
  </Card>
</TabsContent>
```

#### 4.1.2 新增Tab：项目进展

```jsx
<TabsContent value="projects" className="space-y-6">
  {/* 在产项目列表 */}
  <Card>
    <CardHeader>
      <CardTitle>在产项目进度</CardTitle>
    </CardHeader>
    <CardContent>
      {/* 调用 /projects/in-production/summary */}
      {/* 展示：项目名称、阶段、进度、健康度、延期风险 */}
    </CardContent>
  </Card>
</TabsContent>
```

#### 4.1.3 增强缺料数据展示

```jsx
<TabsContent value="shortage" className="space-y-6">
  {/* 缺料预警统计 */}
  <Card>
    <CardHeader>
      <CardTitle>缺料预警</CardTitle>
    </CardHeader>
    <CardContent>
      {/* 已有缺料日报，增强展示 */}
    </CardContent>
  </Card>
  
  {/* 物料查找 */}
  <Card>
    <CardHeader>
      <CardTitle>物料查找</CardTitle>
    </CardHeader>
    <CardContent>
      <Input 
        placeholder="搜索物料编码/名称/规格..."
        onChange={(e) => searchMaterials(e.target.value)}
      />
      {/* 调用 /materials/search */}
      {/* 展示：物料信息、库存、在途、可用数量 */}
    </CardContent>
  </Card>
</TabsContent>
```

---

### 4.2 生产总监工作台增强

**文件**：`frontend/src/pages/ManufacturingDirectorDashboard.jsx`

#### 4.2.1 替换客服部Mock数据

```jsx
// 在 loadDashboard 中
const loadServiceStats = async () => {
  try {
    const res = await serviceApi.dashboardStatistics()
    setServiceStats(res.data)
  } catch (err) {
    console.error('Failed to load service stats:', err)
  }
}
```

#### 4.2.2 替换仓储部Mock数据

```jsx
// 在 loadDashboard 中
const loadWarehouseStats = async () => {
  try {
    const res = await warehouseApi.statistics()
    setWarehouseStats(res.data)
  } catch (err) {
    console.error('Failed to load warehouse stats:', err)
  }
}
```

#### 4.2.3 替换发货部Mock数据

```jsx
// 在 loadDashboard 中
const loadShippingStats = async () => {
  try {
    const res = await businessSupportApi.deliveryOrders.statistics()
    setShippingStats(res.data)
  } catch (err) {
    console.error('Failed to load shipping stats:', err)
  }
}
```

---

## 五、实施计划

### 5.1 第一阶段（1周）

**目标**：人员绩效和项目进展

1. ✅ 实现人员绩效排名API
2. ✅ 实现在产项目进度汇总API
3. ✅ 前端：生产部经理工作台新增"人员绩效"和"项目进展"Tab

---

### 5.2 第二阶段（1周）

**目标**：客服、仓储、发货真实数据

1. ✅ 实现客服统计API
2. ✅ 实现仓储统计API
3. ✅ 实现发货统计API
4. ✅ 前端：生产总监工作台替换Mock数据

---

### 5.3 第三阶段（3-5天）

**目标**：缺料找料数据增强

1. ✅ 实现物料查找API
2. ✅ 前端：生产部经理工作台增强缺料数据展示
3. ✅ 前端：新增物料查找功能

---

## 六、API接口汇总

### 6.1 新增API列表

| API路径 | 方法 | 说明 | 优先级 |
|---------|------|------|--------|
| `/production/reports/worker-ranking` | GET | 人员绩效排名 | P0 |
| `/projects/in-production/summary` | GET | 在产项目进度汇总 | P0 |
| `/service/dashboard-statistics` | GET | 客服统计 | P0 |
| `/warehouse/statistics` | GET | 仓储统计 | P0 |
| `/business-support/delivery-orders/statistics` | GET | 发货统计 | P0 |
| `/materials/search` | GET | 物料查找 | P1 |

---

## 七、数据模型补充

### 7.1 Schema定义

**文件**：`app/schemas/production.py`

```python
class WorkerRankingResponse(BaseModel):
    rank: int
    worker_id: int
    worker_name: str
    workshop_name: Optional[str]
    efficiency: float
    output: int
    quality_rate: float
    total_hours: float
    score: float

class InProductionProjectSummary(BaseModel):
    project_id: int
    project_code: str
    project_name: str
    stage: str
    health: str
    progress: float
    planned_end_date: Optional[date]
    actual_end_date: Optional[date]
    overdue_milestones_count: int
    next_milestone: Optional[str]
    next_milestone_date: Optional[date]
```

**文件**：`app/schemas/service.py`

```python
class ServiceDashboardStatistics(BaseModel):
    active_cases: int
    resolved_today: int
    pending_cases: int
    avg_response_time: float
    customer_satisfaction: float
    on_site_services: int
    total_engineers: int
    active_engineers: int
```

**文件**：`app/schemas/material.py`

```python
class WarehouseStatistics(BaseModel):
    total_items: int
    in_stock_items: int
    low_stock_items: int
    out_of_stock_items: int
    inventory_turnover: float
    warehouse_utilization: float
    pending_inbound: int
    pending_outbound: int

class MaterialSearchResponse(BaseModel):
    material_id: int
    material_code: str
    material_name: str
    specification: Optional[str]
    category: Optional[str]
    current_stock: float
    safety_stock: float
    in_transit_qty: float
    available_qty: float
    unit: str
    unit_price: float
    supplier_name: Optional[str]
```

**文件**：`app/schemas/business_support.py`

```python
class DeliveryStatistics(BaseModel):
    pending_shipments: int
    shipped_today: int
    in_transit: int
    delivered_this_week: int
    on_time_shipping_rate: float
    avg_shipping_time: float
    total_orders: int
```

---

## 八、总结

### 8.1 实现内容

1. ✅ **人员绩效排名**：按效率/产出/质量排名
2. ✅ **在产项目进度**：项目阶段、里程碑、延期风险
3. ✅ **客服真实数据**：服务案例、满意度、响应时间
4. ✅ **仓储真实数据**：库存统计、周转率、利用率
5. ✅ **发货真实数据**：发货统计、准时率、在途订单
6. ✅ **物料查找功能**：支持编码/名称/规格搜索

### 8.2 预期效果

- 生产总监和生产部经理能够全面掌握人员绩效和项目进展
- 生产总监能够看到客服、仓储、发货的真实运营数据
- 生产部经理能够快速查找物料，了解缺料情况

### 8.3 后续优化

- 增加数据可视化（图表）
- 增加数据导出功能
- 增加数据钻取功能（点击查看详情）
